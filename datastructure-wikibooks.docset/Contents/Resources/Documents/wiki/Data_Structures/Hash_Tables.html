<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta charset="UTF-8" /><title>Data Structures/Hash Tables - Wikibooks, open books for an open world</title>
<meta name="generator" content="MediaWiki 1.23wmf7" />
<link rel="alternate" type="application/x-wiki" title="Edit" href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit" />
<link rel="edit" title="Edit" href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit" />
<link rel="shortcut icon" href="//bits.wikimedia.org/favicon/wikibooks.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikibooks (en)" />
<link rel="EditURI" type="application/rsd+xml" href="//en.wikibooks.org/w/api.php?action=rsd" />
<link rel="copyright" href="//creativecommons.org/licenses/by-sa/3.0/" />
<link rel="alternate" type="application/atom+xml" title="Wikibooks Atom feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="canonical" href="http://en.wikibooks.org/wiki/Data_Structures/Hash_Tables" />
<link rel="stylesheet" href="//bits.wikimedia.org/en.wikibooks.org/load.php?debug=false&amp;lang=en&amp;modules=ext.flaggedRevs.basic%7Cext.gadget.extlinks%7Cext.geshi.local%7Cext.uls.nojs%7Cext.wikihiero%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmw.PopUpMediaTransform%7Cskins.vector&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="//bits.wikimedia.org/en.wikibooks.org/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: enwikibooks:resourceloader:filter:minify-css:7:4969bf752d40e7c60e4c1bc8e4153549 */</style>

<script src="//bits.wikimedia.org/en.wikibooks.org/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Data_Structures/Hash_Tables","wgTitle":"Data Structures/Hash Tables","wgCurRevisionId":2499014,"wgRevisionId":2499014,"wgArticleId":20098,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Data Structures"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Data_Structures/Hash_Tables","wgIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"templateEditor":false,"templates":false,"preview":false,"previewDialog":false,"publish":false,"toc":false},"wgBetaFeaturesFeatures":[],"wgULSAcceptLanguageList":[],"wgFlaggedRevsParams":{"tags":{"value":{"levels":3,"quality":2,"pristine":3}}},"wgStableRevisionId":2499014,"wgCategoryTreePageCategoryOptions":"{\"mode\":0,\"hideprefix\":20,\"showcount\":true,\"namespaces\":false}","Geo":{"city":"","country":""},"wgNoticeProject":"wikibooks"});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":0,"minordefault":0,"newpageshidepatrolled":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":false,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":4,"underline":2,"uselivepreview":0,"usenewrc":0,"vector-simplesearch":1,"watchcreations":1,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,
"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"useeditwarning":1,"prefershttps":1,"flaggedrevssimpleui":0,"flaggedrevsstable":0,"flaggedrevseditdiffs":true,"flaggedrevsviewdiffs":false,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"echo-notify-show-link":true,"echo-show-alert":true,"echo-email-frequency":0,"echo-email-format":"html","echo-subscriptions-email-system":true,"echo-subscriptions-web-system":true,"echo-subscriptions-email-other":false,"echo-subscriptions-web-other":true,"echo-subscriptions-email-edit-user-talk":false,"echo-subscriptions-web-edit-user-talk":true,"echo-subscriptions-email-reverted":false,"echo-subscriptions-web-reverted":true,"echo-subscriptions-email-article-linked":false,"echo-subscriptions-web-article-linked":false,"echo-subscriptions-email-mention":false,"echo-subscriptions-web-mention":true,"echo-subscriptions-web-edit-thank":true,"echo-subscriptions-email-edit-thank":false,"uls-preferences":"","language":
"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":true,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"searchNs102":false,"searchNs103":false,"searchNs108":false,"searchNs109":false,"searchNs110":false,"searchNs111":false,"searchNs112":true,"searchNs113":false,"searchNs828":false,"searchNs829":false,"gadget-extlinks":1,"gadget-commons-file":1,"gadget-toolboxcompat":1,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: enwikibooks:resourceloader:filter:minify-js:7:654df7e16c6905f951b4f215c0323024 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","ext.centralauth.centralautologin","ext.uls.init","ext.uls.interface","ext.centralNotice.bannerController","skins.vector.js"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.c.source-c .de1, .c.source-c .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.c.source-c  {font-family:monospace;}
.c.source-c .imp {font-weight: bold; color: red;}
.c.source-c li, .c.source-c .li1 {font-weight: normal; vertical-align:top;}
.c.source-c .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.c.source-c .li2 {font-weight: bold; vertical-align:top;}
.c.source-c .kw1 {color: #b1b100;}
.c.source-c .kw2 {color: #000000; font-weight: bold;}
.c.source-c .kw3 {color: #000066;}
.c.source-c .kw4 {color: #993333;}
.c.source-c .co1 {color: #666666; font-style: italic;}
.c.source-c .co2 {color: #339933;}
.c.source-c .coMULTI {color: #808080; font-style: italic;}
.c.source-c .es0 {color: #000099; font-weight: bold;}
.c.source-c .es1 {color: #000099; font-weight: bold;}
.c.source-c .es2 {color: #660099; font-weight: bold;}
.c.source-c .es3 {color: #660099; font-weight: bold;}
.c.source-c .es4 {color: #660099; font-weight: bold;}
.c.source-c .es5 {color: #006699; font-weight: bold;}
.c.source-c .br0 {color: #009900;}
.c.source-c .sy0 {color: #339933;}
.c.source-c .st0 {color: #ff0000;}
.c.source-c .nu0 {color: #0000dd;}
.c.source-c .nu6 {color: #208080;}
.c.source-c .nu8 {color: #208080;}
.c.source-c .nu12 {color: #208080;}
.c.source-c .nu16 {color:#800080;}
.c.source-c .nu17 {color:#800080;}
.c.source-c .nu18 {color:#800080;}
.c.source-c .nu19 {color:#800080;}
.c.source-c .me1 {color: #202020;}
.c.source-c .me2 {color: #202020;}
.c.source-c .ln-xtra, .c.source-c li.ln-xtra, .c.source-c div.ln-xtra {background-color: #ffc;}
.c.source-c span.xtra { display:block; }

/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-python {line-height: normal;}
.source-python li, .source-python pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for python
 * CSS class: source-python, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.python.source-python .de1, .python.source-python .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.python.source-python  {font-family:monospace;}
.python.source-python .imp {font-weight: bold; color: red;}
.python.source-python li, .python.source-python .li1 {font-weight: normal; vertical-align:top;}
.python.source-python .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.python.source-python .li2 {font-weight: bold; vertical-align:top;}
.python.source-python .kw1 {color: #ff7700;font-weight:bold;}
.python.source-python .kw2 {color: #008000;}
.python.source-python .kw3 {color: #dc143c;}
.python.source-python .kw4 {color: #0000cd;}
.python.source-python .co1 {color: #808080; font-style: italic;}
.python.source-python .coMULTI {color: #808080; font-style: italic;}
.python.source-python .es0 {color: #000099; font-weight: bold;}
.python.source-python .br0 {color: black;}
.python.source-python .sy0 {color: #66cc66;}
.python.source-python .st0 {color: #483d8b;}
.python.source-python .nu0 {color: #ff4500;}
.python.source-python .me1 {color: black;}
.python.source-python .ln-xtra, .python.source-python li.ln-xtra, .python.source-python div.ln-xtra {background-color: #ffc;}
.python.source-python span.xtra { display:block; }

/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-java {line-height: normal;}
.source-java li, .source-java pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for java
 * CSS class: source-java, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.java.source-java .de1, .java.source-java .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.java.source-java  {font-family:monospace;}
.java.source-java .imp {font-weight: bold; color: red;}
.java.source-java li, .java.source-java .li1 {font-weight: normal; vertical-align:top;}
.java.source-java .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.java.source-java .li2 {font-weight: bold; vertical-align:top;}
.java.source-java .kw1 {color: #000000; font-weight: bold;}
.java.source-java .kw2 {color: #000066; font-weight: bold;}
.java.source-java .kw3 {color: #003399;}
.java.source-java .kw4 {color: #000066; font-weight: bold;}
.java.source-java .co1 {color: #666666; font-style: italic;}
.java.source-java .co2 {color: #006699;}
.java.source-java .co3 {color: #008000; font-style: italic; font-weight: bold;}
.java.source-java .coMULTI {color: #666666; font-style: italic;}
.java.source-java .es0 {color: #000099; font-weight: bold;}
.java.source-java .br0 {color: #009900;}
.java.source-java .sy0 {color: #339933;}
.java.source-java .st0 {color: #0000ff;}
.java.source-java .nu0 {color: #cc66cc;}
.java.source-java .me1 {color: #006633;}
.java.source-java .me2 {color: #006633;}
.java.source-java .ln-xtra, .java.source-java li.ln-xtra, .java.source-java div.ln-xtra {background-color: #ffc;}
.java.source-java span.xtra { display:block; }

/*]]>*/
</style><script src="//bits.wikimedia.org/geoiplookup"></script><link rel="dns-prefetch" href="//meta.wikimedia.org" /><!--[if lt IE 7]><style type="text/css">body{behavior:url("/w/static-1.23wmf7/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Data_Structures_Hash_Tables skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<div id="siteNotice"><!-- CentralNotice --></div>
						<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Data Structures/Hash Tables</span></h1>
			<div id="bodyContent">
								<div id="siteSub">From Wikibooks, open books for an open world</div>
								<div id="contentSub"><span class="subpages">&lt; <a href="/wiki/Data_Structures" title="Data Structures">Data Structures</a></span></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-navigation">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p></p>
<div id="toc" class="toc">
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Hash_Tables"><span class="tocnumber">1</span> <span class="toctext">Hash Tables</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Time_complexity_and_common_uses_of_hash_tables"><span class="tocnumber">1.1</span> <span class="toctext">Time complexity and common uses of hash tables</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Choosing_a_good_hash_function"><span class="tocnumber">1.2</span> <span class="toctext">Choosing a good hash function</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Collision_resolution"><span class="tocnumber">1.3</span> <span class="toctext">Collision resolution</span></a>
<ul>
<li class="toclevel-3 tocsection-5"><a href="#Chaining"><span class="tocnumber">1.3.1</span> <span class="toctext">Chaining</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="#Open_addressing"><span class="tocnumber">1.3.2</span> <span class="toctext">Open addressing</span></a>
<ul>
<li class="toclevel-4 tocsection-7"><a href="#Example_pseudocode"><span class="tocnumber">1.3.2.1</span> <span class="toctext">Example pseudocode</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-8"><a href="#Open_addressing_versus_chaining"><span class="tocnumber">1.3.3</span> <span class="toctext">Open addressing versus chaining</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#Coalesced_hashing"><span class="tocnumber">1.3.4</span> <span class="toctext">Coalesced hashing</span></a></li>
<li class="toclevel-3 tocsection-10"><a href="#Perfect_hashing"><span class="tocnumber">1.3.5</span> <span class="toctext">Perfect hashing</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="#Probabilistic_hashing"><span class="tocnumber">1.3.6</span> <span class="toctext">Probabilistic hashing</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-12"><a href="#Table_resizing"><span class="tocnumber">1.4</span> <span class="toctext">Table resizing</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Ordered_retrieval_issue"><span class="tocnumber">1.5</span> <span class="toctext">Ordered retrieval issue</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Problems_with_hash_tables"><span class="tocnumber">1.6</span> <span class="toctext">Problems with hash tables</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Other_hash_table_algorithms"><span class="tocnumber">1.7</span> <span class="toctext">Other hash table algorithms</span></a>
<ul>
<li class="toclevel-3 tocsection-16"><a href="#A_simple_inference_on_file_storage_mapping_of_linear_hashing_and_extendible_hashing"><span class="tocnumber">1.7.1</span> <span class="toctext">A simple inference on file storage mapping of linear hashing and extendible hashing</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-17"><a href="#Implementations"><span class="tocnumber">1.8</span> <span class="toctext">Implementations</span></a>
<ul>
<li class="toclevel-3 tocsection-18"><a href="#A_python_implementation_of_extendible_hashing"><span class="tocnumber">1.8.1</span> <span class="toctext">A python implementation of extendible hashing</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="#A_Java_implementation_of_extendible_hashing"><span class="tocnumber">1.8.2</span> <span class="toctext">A Java implementation of extendible hashing</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="#A_Java_implementation_of_linear_hashing"><span class="tocnumber">1.8.3</span> <span class="toctext">A Java implementation of linear hashing</span></a>
<ul>
<li class="toclevel-4 tocsection-21"><a href="#debugging_to_achieve_functionality"><span class="tocnumber">1.8.3.1</span> <span class="toctext">debugging to achieve functionality</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p></p>
<h2><span class="mw-headline" id="Hash_Tables">Hash Tables</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=1" title="Edit section: Hash Tables">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div style="clear: both"></div>
<table style="background: #ffd; border: 1px solid #aaaaaa; padding: 6pt; margin: 12pt 8%; width: 60%; margin: auto;" class="notice noprint notice-todo">
<tr>
<td style="width: 58px;">
<div class="floatleft"><img alt="Clipboard" src="//upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Clipboard.svg/45px-Clipboard.svg.png" width="45" height="45" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Clipboard.svg/68px-Clipboard.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Clipboard.svg/90px-Clipboard.svg.png 2x" /></div>
</td>
<td>
<p><b>To do:</b><br /></p>
<pre>
 Define and describe what a hash table is
  - Introduce key/value relationships
  - Introduce concepts such as table size (why are prime numbers important?) 
     and other aspects of tables that are independent of type and method of
     implementation.
  - Define "n" for time-complexity.  record? key?  
</pre>
<pre>
 Iteration order for hash tables by augmenting the structure
  - iterating over items in the order in which they were inserted
  - iterating over the items based on most-recently-used
</pre></td>
</tr>
</table>
<div style="clear: both"></div>
<p>A <b>hash table</b>, or a <b>hash map</b>, is a data structure that associates <i>keys</i> with <i>values</i>. The primary operation it supports efficiently is a <i>lookup</i>: given a key (e.g. a person's name), find the corresponding value (e.g. that person's telephone number). It works by transforming the key using a <a href="//en.wikipedia.org/wiki/hash_function" class="extiw" title="w:hash function">hash function</a> into a <i>hash</i>, a number that the hash table uses to locate the desired value.</p>
<div class="thumb tright">
<div class="thumbinner" style="width:364px;"><a href="/wiki/File:HASHTB08.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/c/c2/HASHTB08.svg/362px-HASHTB08.svg.png" width="362" height="195" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/c/c2/HASHTB08.svg/543px-HASHTB08.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/c/c2/HASHTB08.svg/724px-HASHTB08.svg.png 2x" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:HASHTB08.svg" class="internal" title="Enlarge"><img src="//bits.wikimedia.org/static-1.23wmf4/skins/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
A small phone book as a hash table.</div>
</div>
</div>
<h3><span class="mw-headline" id="Time_complexity_and_common_uses_of_hash_tables">Time complexity and common uses of hash tables</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=2" title="Edit section: Time complexity and common uses of hash tables">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Hash tables are often used to implement <a href="//en.wikipedia.org/wiki/associative_array" class="extiw" title="w:associative array">associative arrays</a>, <a href="//en.wikipedia.org/wiki/Set_(computer_science)" class="extiw" title="w:Set (computer science)">sets</a> and <a href="//en.wikipedia.org/wiki/cache" class="extiw" title="w:cache">caches</a>. Like <a href="//en.wikipedia.org/wiki/array" class="extiw" title="w:array">arrays</a>, hash tables provide constant-time <a href="//en.wikipedia.org/wiki/Big-O_notation" class="extiw" title="w:Big-O notation">O(1)</a> lookup on average, regardless of the number of items in the table. However, the rare worst-case lookup time can be as bad as O(<i>n</i>). Compared to other associative array data structures, hash tables are most useful when large numbers of records of data are to be stored.</p>
<p>Hash tables may be used as in-memory data structures. Hash tables may also be adopted for use with <a href="//en.wikipedia.org/wiki/persistent_data_structure" class="extiw" title="w:persistent data structure">persistent data structures</a>; database indexes commonly use disk-based data structures based on hash tables.</p>
<p>Hash tables are used to speed-up string searching in many implementations of <a href="/wiki/Data_Compression/Dictionary_compression#hash_tables" title="Data Compression/Dictionary compression">data compression</a>.</p>
<p>In <a href="//en.wikipedia.org/wiki/computer_chess" class="extiw" title="w:computer chess">computer chess</a>, a hash table is generally used to implement the <a href="//en.wikipedia.org/wiki/transposition_table" class="extiw" title="w:transposition table">transposition table</a>.</p>
<h3><span class="mw-headline" id="Choosing_a_good_hash_function">Choosing a good hash function</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=3" title="Edit section: Choosing a good hash function">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A good hash function is essential for good hash table performance. A poor choice of hash function is likely to lead to <i>clustering</i>, in which probability of keys mapping to the same hash bucket (i.e. a <i>collision</i>) is significantly greater than would be expected from a random function. Nonzero probability of collisions is inevitable in any hash implementation, but usually the number of operations to resolve collisions scales linearly with the number of keys mapping to the same bucket, so excess collisions will degrade performance significantly. In addition, some hash functions are computationally expensive, so the amount of time (and, in some cases, memory) taken to compute the hash may be burdensome.</p>
<p>Choosing a good hash function is tricky. The literature is replete with poor choices, at least when measured by modern standards. For example, the very popular multiplicative hash advocated by Knuth in The Art of Computer Programming (see reference below) has particularly poor clustering behavior. However, since poor hashing merely degrades hash table performance for particular input key distributions, such problems commonly go undetected.</p>
<p>The literature is similarly sparse on the criteria for choosing a hash function. Unlike most other fundamental algorithms and data structures, there is no universal consensus on what makes a "good" hash function. The remainder of this section is organized by three criteria: simplicity, speed, and strength, and will survey algorithms known to perform well by these criteria.</p>
<p>Simplicity and speed are readily measured objectively (by number of lines of code and CPU benchmarks, for example), but strength is a more slippery concept. Obviously, a <a href="//en.wikipedia.org/wiki/Cryptographic_hash_function" class="extiw" title="w:Cryptographic hash function">cryptographic hash function</a> such as SHA-1 would satisfy the relatively lax strength requirements needed for hash tables, but their slowness and complexity makes them unappealing. In fact, even a cryptographic hash does not provide protection against an adversary who wishes to degrade hash table performance by choosing keys all hashing to the same bucket. For these specialized cases, a <a href="/w/index.php?title=Universal_hash_function&amp;action=edit&amp;redlink=1" class="new" title="Universal hash function (does not exist)">universal hash function</a> should be used instead of any one static hash, no matter how sophisticated.</p>
<p>In the absence of a standard measure for hash function strength, the current state of the art is to employ a battery of <a href="/wiki/Statistics" title="Statistics">statistical</a> tests to measure whether the hash function can be readily distinguished from a random function. Arguably the most important such test is to determine whether the hash function displays the <a href="/w/index.php?title=Avalanche_effect&amp;action=edit&amp;redlink=1" class="new" title="Avalanche effect (does not exist)">avalanche effect</a>, which essentially states that any single-bit change in the input key should affect on average half the bits in the output. Bret Mulvey advocates testing the <i>strict avalanche condition</i> in particular, which states that, for any single-bit change, each of the output bits should change with probability one-half, independent of the other bits in the key. Purely additive hash functions such as <a href="/w/index.php?title=Cyclic_redundancy_check&amp;action=edit&amp;redlink=1" class="new" title="Cyclic redundancy check (does not exist)">CRC</a> fail this stronger condition miserably.</p>
<p>Clearly, a strong hash function should have a <a href="/w/index.php?title=Uniform_distribution&amp;action=edit&amp;redlink=1" class="new" title="Uniform distribution (does not exist)">uniform distribution</a> of hash values. Bret Mulvey proposes the use of a chi-squared test for uniformity, based on <a href="/w/index.php?title=Power_of_two&amp;action=edit&amp;redlink=1" class="new" title="Power of two (does not exist)">power of two</a> hash table sizes ranging from 2<sup>1</sup> to 2<sup>16</sup>. This test is considerably more sensitive than many others proposed for measuring hash functions, and finds problems in many popular hash functions.</p>
<p>Fortunately, there are good hash functions that satisfy all these criteria. The simplest class all consume one byte of the input key per iteration of the inner loop. Within this class, simplicity and speed are closely related, as fast algorithms simply don't have time to perform complex calculations. Of these, one that performs particularly well is the Jenkins One-at-a-time hash, adapted here from <a rel="nofollow" class="external text" href="http://www.burtleburtle.net/bob/hash/doobs.html">an article by Bob Jenkins</a>, its creator.</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="c source-c">
<pre class="de1">
  <span class="kw4">uint32</span> joaat_hash<span class="br0">(</span>uchar <span class="sy0">*</span>key<span class="sy0">,</span> <span class="kw4">size_t</span> len<span class="br0">)</span>
  <span class="br0">{</span>
    <span class="kw4">uint32</span> hash <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
    <span class="kw4">size_t</span> i<span class="sy0">;</span>
 
    <span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
    <span class="br0">{</span>
        hash <span class="sy0">+=</span> key<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
        hash <span class="sy0">+=</span> <span class="br0">(</span>hash <span class="sy0">&lt;&lt;</span> <span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
        hash <span class="sy0">^=</span> <span class="br0">(</span>hash <span class="sy0">&gt;&gt;</span> <span class="nu0">6</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    hash <span class="sy0">+=</span> <span class="br0">(</span>hash <span class="sy0">&lt;&lt;</span> <span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span>
    hash <span class="sy0">^=</span> <span class="br0">(</span>hash <span class="sy0">&gt;&gt;</span> <span class="nu0">11</span><span class="br0">)</span><span class="sy0">;</span>
    hash <span class="sy0">+=</span> <span class="br0">(</span>hash <span class="sy0">&lt;&lt;</span> <span class="nu0">15</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> hash<span class="sy0">;</span>
<span class="br0">}</span>
</pre></div>
</div>
<div class="thumb tright">
<div class="thumbinner" style="width:257px;"><a href="/wiki/File:JenkinsOneAtATime-3.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/3/3d/JenkinsOneAtATime-3.svg/255px-JenkinsOneAtATime-3.svg.png" width="255" height="191" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/3/3d/JenkinsOneAtATime-3.svg/383px-JenkinsOneAtATime-3.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/3/3d/JenkinsOneAtATime-3.svg/510px-JenkinsOneAtATime-3.svg.png 2x" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:JenkinsOneAtATime-3.svg" class="internal" title="Enlarge"><img src="//bits.wikimedia.org/static-1.23wmf4/skins/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
Avalanche behavior of Jenkins One-at-a-time hash over 3-byte keys</div>
</div>
</div>
<p>The avalanche behavior of this hash shown on the right. The image was made using Bret Mulvey's AvalancheTest in his <a rel="nofollow" class="external text" href="http://bretm.home.comcast.net/hash/11.html">Hash.cs toolset</a>. Each row corresponds to a single bit in the input, and each column to a bit in the output. A green square indicates good mixing behavior, a yellow square weak mixing behavior, and red would indicate no mixing. Only a few bits in the last byte are weakly mixed, a performance vastly better than a number of widely used hash functions.</p>
<p>Many commonly used hash functions perform poorly when subjected to such rigorous avalanche testing. The widely favored <a href="/w/index.php?title=Fowler_Noll_Vo_hash&amp;action=edit&amp;redlink=1" class="new" title="Fowler Noll Vo hash (does not exist)">FNV</a> hash, for example, shows many bits with no mixing at all, especially for short keys. See the <a rel="nofollow" class="external text" href="http://bretm.home.comcast.net/hash/6.html">evaluation of FNV</a> by Bret Mulvey for a more thorough analysis.</p>
<p>If speed is more important than simplicity, then the class of hash functions which consume multibyte chunks per iteration may be of interest. One of the most sophisticated is "lookup3" by Bob Jenkins, which consumes input in 12 byte (96 bit) chunks. Note, though, that any speed improvement from the use of this hash is only likely to be useful for large keys, and that the increased complexity may also have speed consequences such as preventing an optimizing compiler from inlining the hash function. Bret Mulvey analyzed an <a rel="nofollow" class="external text" href="http://bretm.home.comcast.net/hash/7.html">earlier version, lookup2</a>, and found it to have excellent avalanche behavior.</p>
<p>One desirable property of a hash function is that conversion from the hash value (typically 32 bits) to an bucket index for a particular-size hash table can be done simply by masking, preserving only the lower k bits for a table of size 2<sup>k</sup> (an operation equivalent to computing the hash value <a href="/w/index.php?title=Modular_arithmetic&amp;action=edit&amp;redlink=1" class="new" title="Modular arithmetic (does not exist)">modulo</a> the table size). This property enables the technique of incremental doubling of the size of the hash table - each bucket in the old table maps to only two in the new table. Because of its use of XOR-folding, the FNV hash does not have this property. Some older hashes are even worse, requiring table sizes to be a prime number rather than a power of two, again computing the bucket index as the hash value modulo the table size. In general, such a requirement is a sign of a fundamentally weak function; using a prime table size is a poor substitute for using a stronger function.</p>
<h3><span class="mw-headline" id="Collision_resolution">Collision resolution</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=4" title="Edit section: Collision resolution">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>If two keys hash to the same index, the corresponding records cannot be stored in the same location. So, if it's already occupied, we must find another location to store the new record, and do it so that we can find it when we look it up later on.</p>
<p>To give an idea of the importance of a good collision resolution strategy, consider the following result, derived using the <a href="//en.wikipedia.org/wiki/Birthday_paradox#Generalization" class="extiw" title="w:Birthday paradox">birthday paradox</a>. Even if we assume that our hash function outputs random indices <a href="//en.wikipedia.org/wiki/Uniform_distribution_(discrete)" class="extiw" title="w:Uniform distribution (discrete)">uniformly distributed</a> over the array, and even for an array with 1 million entries, there is a 95% chance of at least one collision occurring before it contains 2500 records.</p>
<p>There are a number of collision resolution techniques, but the most popular are <i>chaining</i> and <i>open addressing</i>.</p>
<h4><span class="mw-headline" id="Chaining">Chaining</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=5" title="Edit section: Chaining">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div class="thumb tright">
<div class="thumbinner" style="width:364px;"><a href="/wiki/File:HASHTB32.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/3/34/HASHTB32.svg/362px-HASHTB32.svg.png" width="362" height="195" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/3/34/HASHTB32.svg/543px-HASHTB32.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/3/34/HASHTB32.svg/724px-HASHTB32.svg.png 2x" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:HASHTB32.svg" class="internal" title="Enlarge"><img src="//bits.wikimedia.org/static-1.23wmf4/skins/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
Hash collision resolved by chaining.</div>
</div>
</div>
<p>In the simplest chained hash table technique, each slot in the array references a <a href="/w/index.php?title=Linked_list&amp;action=edit&amp;redlink=1" class="new" title="Linked list (does not exist)">linked list</a> of inserted records that collide to the same slot. Insertion requires finding the correct slot, and appending to either end of the list in that slot; deletion requires searching the list and removal.</p>
<p>Chained hash tables have advantages over open addressed hash tables in that the removal operation is simple and resizing the table can be postponed for a much longer time because performance <a href="//en.wikipedia.org/wiki/graceful_degradation" class="extiw" title="w:graceful degradation">degrades more gracefully</a> even when every slot is used. Indeed, many chaining hash tables may not require resizing at all since performance degradation is linear as the table fills. For example, a chaining hash table containing twice its recommended capacity of data would only be about twice as slow on average as the same table at its recommended capacity.</p>
<p>Chained hash tables inherit the disadvantages of linked lists. When storing small records, the overhead of the linked list can be significant. An additional disadvantage is that traversing a linked list has poor <a href="//en.wikipedia.org/wiki/Locality_of_reference" class="extiw" title="w:Locality of reference">cache performance</a>.</p>
<p>Alternative data structures can be used for chains instead of linked lists. By using a <a href="//en.wikipedia.org/wiki/Self-balancing_binary_search_tree" class="extiw" title="w:Self-balancing binary search tree">self-balancing tree</a>, for example, the theoretical worst-case time of a hash table can be brought down to O(log <i>n</i>) rather than O(<i>n</i>). However, since each list is intended to be short, this approach is usually inefficient unless the hash table is designed to run at full capacity or there are unusually high collision rates, as might occur in input designed to cause collisions. <a href="/w/index.php?title=Dynamic_array&amp;action=edit&amp;redlink=1" class="new" title="Dynamic array (does not exist)">Dynamic arrays</a> can also be used to decrease space overhead and improve cache performance when records are small.</p>
<p>Some chaining implementations use an optimization where the first record of each chain is stored in the table. Although this can increase performance, it is generally not recommended: chaining tables with reasonable load factors contain a large proportion of empty slots, and the larger slot size causes them to waste large amounts of space.</p>
<h4><span class="mw-headline" id="Open_addressing">Open addressing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=6" title="Edit section: Open addressing">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div class="thumb tright">
<div class="thumbinner" style="width:364px;"><a href="/wiki/File:HASHTB12.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/9/90/HASHTB12.svg/362px-HASHTB12.svg.png" width="362" height="226" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/9/90/HASHTB12.svg/543px-HASHTB12.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/9/90/HASHTB12.svg/724px-HASHTB12.svg.png 2x" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:HASHTB12.svg" class="internal" title="Enlarge"><img src="//bits.wikimedia.org/static-1.23wmf4/skins/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
Hash collision resolved by linear probing (interval=1).</div>
</div>
</div>
<p>Open addressing hash tables can store the records directly within the array. A hash collision is resolved by <i>probing</i>, or searching through alternate locations in the array (the <i>probe sequence</i>) until either the target record is found, or an unused array slot is found, which indicates that there is no such key in the table. Well known probe sequences include:</p>
<dl>
<dt><a href="/w/index.php?title=Linear_probing&amp;action=edit&amp;redlink=1" class="new" title="Linear probing (does not exist)">linear probing</a>&#160;</dt>
<dd>in which the interval between probes is fixedâ€”often at 1,</dd>
<dt><a href="/w/index.php?title=Quadratic_probing&amp;action=edit&amp;redlink=1" class="new" title="Quadratic probing (does not exist)">quadratic probing</a>&#160;</dt>
<dd>in which the interval between probes increases linearly (hence, the indices are described by a quadratic function), and</dd>
<dt><a href="/w/index.php?title=Double_hashing&amp;action=edit&amp;redlink=1" class="new" title="Double hashing (does not exist)">double hashing</a>&#160;</dt>
<dd>in which the interval between probes is fixed for each record but is computed by another hash function.</dd>
</dl>
<p>The main tradeoffs between these methods are that linear probing has the best cache performance but is most sensitive to clustering, while double hashing has poor cache performance but exhibits virtually no clustering; quadratic hashing falls in-between in both areas. Double hashing can also require more computation than other forms of probing. Some open addressing methods, such as <a href="/w/index.php?title=Last-come-first-served_hashing&amp;action=edit&amp;redlink=1" class="new" title="Last-come-first-served hashing (does not exist)">last-come-first-served hashing</a> and <a href="/w/index.php?title=Cuckoo_hashing&amp;action=edit&amp;redlink=1" class="new" title="Cuckoo hashing (does not exist)">cuckoo hashing</a> move existing keys around in the array to make room for the new key. This gives better maximum search times than the methods based on probing.</p>
<p>A critical influence on performance of an open addressing hash table is the <i>load factor</i>; that is, the proportion of the slots in the array that are used. As the load factor increases towards 100%, the number of probes that may be required to find or insert a given key rises dramatically. Once the table becomes full, probing algorithms may even fail to terminate. Even with good hash functions, load factors are normally limited to 80%. A poor hash function can exhibit poor performance even at very low load factors by generating significant clustering. What causes hash functions to cluster is not well understood, and it is easy to unintentionally write a hash function which causes severe clustering.</p>
<h5><span class="mw-headline" id="Example_pseudocode">Example pseudocode</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=7" title="Edit section: Example pseudocode">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The following <a href="//en.wikipedia.org/wiki/pseudocode" class="extiw" title="w:pseudocode">pseudocode</a> is an implementation of an open addressing hash table with linear probing and single-slot stepping, a common approach that is effective if the hash function is good. Each of the <b>lookup</b>, <b>set</b> and <b>remove</b> functions use a common internal function <b>findSlot</b> to locate the array slot that either does or should contain a given key.</p>
<pre>
 <b>record</b> pair { key, value }
 <b>var</b> <i>pair array</i> slot[0..numSlots-1]
 
 <b>function</b> findSlot(key)
     i := hash(key) modulus numSlots
     <b>loop</b>
         <b>if</b> slot[i] is not occupied <b>or</b> slot[i].key = key
             <b>return</b> i
         i := (i + 1) modulus numSlots
 
 <b>function</b> lookup(key)
     i := findSlot(key)
     <b>if</b> slot[i] is occupied   <i>// key is in table</i>
         <b>return</b> slot[i].value
     <b>else</b>                     <i>// key is not in table</i>
         <b>return</b> not found     
 
 <b>function</b> set(key, value)
     i := findSlot(key)
     <b>if</b> slot[i] is occupied
         slot[i].value := value
     <b>else</b>
         <b>if</b> the table is almost full
             rebuild the table larger <i>(note 1)</i>
             i := findSlot(key)
         slot[i].key   := key
         slot[i].value := value
</pre>
<p>Another example showing open addressing technique. Presented function is converting each part(4) of an Internet protocol address, where NOT is bitwise NOT, XOR is bitwise XOR, OR is bitwise OR, AND is bitwise AND and &lt;&lt; and &gt;&gt; are shift-left and shift-right:</p>
<pre>
 <i>// key_1,key_2,key_3,key_4 are following 3-digit numbers - parts of ip address xxx.xxx.xxx.xxx</i>
 <b>function</b> ip(key parts)
     j := 1
     <b>do</b>
         key := (key_2 &lt;&lt; 2)
         key := (key + (key_3 &lt;&lt; 7))
         key := key + (j OR key_4 &gt;&gt; 2) * (key_4) * (j + key_1) XOR j
         key := key AND _prime_    <i>// _prime_ is a prime number</i>
         j := (j+1) 
     <b>while</b> collision
     <b>return</b> key
</pre>
<dl>
<dt>note 1&#160;</dt>
<dd>Rebuilding the table requires allocating a larger array and recursively using the <b>set</b> operation to insert all the elements of the old array into the new larger array. It is common to increase the array size <a href="/w/index.php?title=Exponential_growth&amp;action=edit&amp;redlink=1" class="new" title="Exponential growth (does not exist)">exponentially</a>, for example by doubling the old array size.</dd>
</dl>
<pre>
 <b>function</b> remove(key)
     i := findSlot(key)
     <b>if</b> slot[i] is unoccupied
         return   <i>// key is not in the table</i>
     j := i
     <b>loop</b>
         j := (j+1) modulus numSlots
         <b>if</b> slot[j] is unoccupied
             <b>exit loop</b>
         k := hash(slot[j].key) modulus numSlots
         <b>if</b> (j &gt; i <b>and</b> (k &lt;= i <b>or</b> k &gt; j)) <b>or</b>
            (j &lt; i <b>and</b> (k &lt;= i <b>and</b> k &gt; j)) <i>(note 2)</i>
             slot[i] := slot[j]
             i := j
     mark slot[i] as unoccupied
</pre>
<dl>
<dt>note 2&#160;</dt>
<dd>For all records in a cluster, there must be no vacant slots between their natural hash position and their current position (else lookups will terminate before finding the record). At this point in the pseudocode, <i>i</i> is a vacant slot that might be invalidating this property for subsequent records in the cluster. <i>j</i> is such as subsequent record. <i>k</i> is the raw hash where the record at <i>j</i> would naturally land in the hash table if there were no collisions. This test is asking if the record at <i>j</i> is invalidly positioned with respect to the required properties of a cluster now that <i>i</i> is vacant.</dd>
</dl>
<p>Another technique for removal is simply to mark the slot as deleted. However this eventually requires rebuilding the table simply to remove deleted records. The methods above provide O(1) updating and removal of existing records, with occasional rebuilding if the high water mark of the table size grows.</p>
<p>The O(1) remove method above is only possible in linearly probed hash tables with single-slot stepping. In the case where many records are to be deleted in one operation, marking the slots for deletion and later rebuilding may be more efficient.</p>
<h4><span class="mw-headline" id="Open_addressing_versus_chaining">Open addressing versus chaining</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=8" title="Edit section: Open addressing versus chaining">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Chained hash tables have the following benefits over open addressing:</p>
<ul>
<li>They are simple to implement effectively and only require basic data structures.</li>
<li>From the point of view of writing suitable hash functions, chained hash tables are insensitive to clustering, only requiring minimization of collisions. Open addressing depends upon better hash functions to avoid clustering. This is particularly important if novice programmers can add their own hash functions, but even experienced programmers can be caught out by unexpected clustering effects.</li>
<li>They degrade in performance more gracefully. Although chains grow longer as the table fills, a chained hash table cannot "fill up" and does not exhibit the sudden increases in lookup times that occur in a near-full table with open addressing. (<i>see right</i>)</li>
<li>If the hash table stores large records, about 5 or more words per record, chaining uses less memory than open addressing.</li>
<li>If the hash table is sparse (that is, it has a big array with many free array slots), chaining uses less memory than open addressing even for small records of 2 to 4 words per record due to its external storage.</li>
</ul>
<div class="thumb tright">
<div class="thumbinner" style="width:364px;"><a href="/wiki/File:Hash_table_average_insertion_time.png" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Hash_table_average_insertion_time.png/362px-Hash_table_average_insertion_time.png" width="362" height="235" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Hash_table_average_insertion_time.png/543px-Hash_table_average_insertion_time.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Hash_table_average_insertion_time.png/724px-Hash_table_average_insertion_time.png 2x" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Hash_table_average_insertion_time.png" class="internal" title="Enlarge"><img src="//bits.wikimedia.org/static-1.23wmf4/skins/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
This graph compares the average number of cache misses required to lookup elements in tables with chaining and linear probing. As the table passes the 80%-full mark, linear probing's performance drastically degrades.</div>
</div>
</div>
<p>For small record sizes (a few words or less) the benefits of in-place open addressing compared to chaining are:</p>
<ul>
<li>They can be more space-efficient than chaining since they don't need to store any pointers or allocate any additional space outside the hash table. Simple linked lists require a word of overhead per element.</li>
<li>Insertions avoid the time overhead of memory allocation, and can even be implemented in the absence of a memory allocator.</li>
<li>Because it uses internal storage, open addressing avoids the extra indirection required for chaining's external storage. It also has better <a href="//en.wikipedia.org/wiki/locality_of_reference" class="extiw" title="w:locality of reference">locality of reference</a>, particularly with linear probing. With small record sizes, these factors can yield better performance than chaining, particularly for lookups.</li>
<li>They can be easier to <a href="//en.wikipedia.org/wiki/serialization" class="extiw" title="w:serialization">serialize</a>, because they don't use pointers.</li>
</ul>
<p>On the other hand, normal open addressing is a poor choice for large elements, since these elements fill entire cache lines (negating the cache advantage), and a large amount of space is wasted on large empty table slots. If the open addressing table only stores references to elements (external storage), it uses space comparable to chaining even for large records but loses its speed advantage.</p>
<p>Generally speaking, open addressing is better used for hash tables with small records that can be stored within the table (internal storage) and fit in a cache line. They are particularly suitable for elements of one word or less. In cases where the tables are expected to have high load factors, the records are large, or the data is variable-sized, chained hash tables often perform as well or better.</p>
<p>Ultimately, used sensibly any kind of hash table algorithm is usually fast <i>enough</i>; and the percentage of a calculation spent in hash table code is low. Memory usage is rarely considered excessive. Therefore, in most cases the differences between these algorithms is marginal, and other considerations typically come into play.</p>
<h4><span class="mw-headline" id="Coalesced_hashing">Coalesced hashing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=9" title="Edit section: Coalesced hashing">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<dl>
<dd><span class="noprint"><i>Main page: <a href="/w/index.php?title=Coalesced_hashing&amp;action=edit&amp;redlink=1" class="new" title="Coalesced hashing (does not exist)">Coalesced hashing</a></i></span></dd>
</dl>
<p>A hybrid of chaining and open addressing, coalesced hashing links together chains of nodes within the table itself. Like open addressing, it achieves space usage and (somewhat diminished) cache advantages over chaining. Like chaining, it does not exhibit clustering effects; in fact, the table can be efficiently filled to a high density. Unlike chaining, it cannot have more elements than table slots.</p>
<h4><span class="mw-headline" id="Perfect_hashing">Perfect hashing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=10" title="Edit section: Perfect hashing">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<dl>
<dd><span class="noprint"><i>Main page: <a href="/w/index.php?title=Perfect_hashing&amp;action=edit&amp;redlink=1" class="new" title="Perfect hashing (does not exist)">Perfect hashing</a></i></span></dd>
</dl>
<p>If all of the keys that will be used are known ahead of time, and there are no more keys that can fit the hash table, <a href="/w/index.php?title=Perfect_hashing&amp;action=edit&amp;redlink=1" class="new" title="Perfect hashing (does not exist)">perfect hashing</a> can be used to create a perfect hash table, in which there will be no collisions. If <a href="/w/index.php?title=Minimal_perfect_hashing&amp;action=edit&amp;redlink=1" class="new" title="Minimal perfect hashing (does not exist)">minimal perfect hashing</a> is used, every location in the hash table can be used as well.</p>
<p>Perfect hashing gives a hash table where the time to make a lookup is constant in the worst case. This is in contrast to chaining and open addressing methods, where the time for lookup is low on average, but may be arbitrarily large. There exist methods for maintaining a perfect hash function under insertions of keys, known as <a href="/w/index.php?title=Dynamic_perfect_hashing&amp;action=edit&amp;redlink=1" class="new" title="Dynamic perfect hashing (does not exist)">dynamic perfect hashing</a>. A simpler alternative, that also gives worst case constant lookup time, is <a href="/w/index.php?title=Cuckoo_hashing&amp;action=edit&amp;redlink=1" class="new" title="Cuckoo hashing (does not exist)">cuckoo hashing</a>.</p>
<h4><span class="mw-headline" id="Probabilistic_hashing">Probabilistic hashing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=11" title="Edit section: Probabilistic hashing">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Perhaps the simplest solution to a collision is to replace the value that is already in the slot with the new value, or slightly less commonly, drop the record that is to be inserted. In later searches, this may result in a search not finding a record which has been inserted. This technique is particularly useful for implementing caching.</p>
<p>An even more space-efficient solution which is similar to this is use a <a href="//en.wikipedia.org/wiki/bit_array" class="extiw" title="w:bit array">bit array</a> (an array of one-bit fields) for our table. Initially all bits are set to zero, and when we insert a key, we set the corresponding bit to one. False negatives cannot occur, but <a href="/w/index.php?title=False_positives&amp;action=edit&amp;redlink=1" class="new" title="False positives (does not exist)">false positives</a> can, since if the search finds a 1 bit, it will claim that the value was found, even if it was just another value that hashed into the same array slot by coincidence. In reality, such a hash table is merely a specific type of <a href="//en.wikipedia.org/wiki/Bloom_filter" class="extiw" title="w:Bloom filter">Bloom filter</a>.</p>
<h3><span class="mw-headline" id="Table_resizing">Table resizing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=12" title="Edit section: Table resizing">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>With a good hash function, a hash table can typically contain about 70%â€“80% as many elements as it does table slots and still perform well. Depending on the collision resolution mechanism, performance can begin to suffer either gradually or dramatically as more elements are added. To deal with this, when the load factor exceeds some threshold, we allocate a new, larger table, and add all the contents of the original table to this new table. In <a href="/w/index.php?title=Java_programming_language&amp;action=edit&amp;redlink=1" class="new" title="Java programming language (does not exist)">Java</a>'s HashMap class, for example, the default load factor threshold is 0.75.</p>
<p>This can be a very expensive operation, and the necessity for it is one of the hash table's disadvantages. In fact, some naive methods for doing this, such as enlarging the table by one each time you add a new element, reduce performance so drastically as to make the hash table useless. However, if we enlarge the table by some fixed percent, such as 10% or 100%, it can be shown using <a href="/w/index.php?title=Amortized_analysis&amp;action=edit&amp;redlink=1" class="new" title="Amortized analysis (does not exist)">amortized analysis</a> that these resizings are so infrequent that the average time per lookup remains constant-time. To see why this is true, suppose a hash table using chaining begins at the minimum size of 1 and is doubled each time it fills above 100%. If in the end it contains <i>n</i> elements, then the total add operations performed for all the resizings is:</p>
<dl>
<dd>1 + 2 + 4 + ... + <i>n</i> = 2<i>n</i> - 1.</dd>
</dl>
<p>Because the costs of the resizings form a <a href="/w/index.php?title=Geometric_series&amp;action=edit&amp;redlink=1" class="new" title="Geometric series (does not exist)">geometric series</a>, the total cost is O(<i>n</i>). But we also perform <i>n</i> operations to add the <i>n</i> elements in the first place, so the total time to add <i>n</i> elements with resizing is O(<i>n</i>), an amortized time of O(1) per element.</p>
<p>On the other hand, some hash table implementations, notably in <a href="/w/index.php?title=Real-time_system&amp;action=edit&amp;redlink=1" class="new" title="Real-time system (does not exist)">real-time systems</a>, cannot pay the price of enlarging the hash table all at once, because it may interrupt time-critical operations. One simple approach is to initially allocate the table with enough space for the expected number of elements and forbid the addition of too many elements. Another useful but more memory-intensive technique is to perform the resizing gradually:</p>
<ul>
<li>Allocate the new hash table, but leave the old hash table and check both tables during lookups.</li>
<li>Each time an insertion is performed, add that element to the new table and also move <i>k</i> elements from the old table to the new table.</li>
<li>When all elements are removed from the old table, deallocate it.</li>
</ul>
<p>To ensure that the old table will be completely copied over before the new table itself needs to be enlarged, it's necessary to increase the size of the table by a factor of at least (<i>k</i> + 1)/<i>k</i> during the resizing.</p>
<p><a href="/w/index.php?title=Linear_hashing&amp;action=edit&amp;redlink=1" class="new" title="Linear hashing (does not exist)">Linear hashing</a> is a hash table algorithm that permits incremental hash table expansion. It is implemented using a single hash table, but with two possible look-up functions.</p>
<p>Another way to decrease the cost of table resizing is to choose a hash function in such a way that the hashes of most values do not change when the table is resized. This approach, called <a href="/w/index.php?title=Consistent_hashing&amp;action=edit&amp;redlink=1" class="new" title="Consistent hashing (does not exist)">consistent hashing</a>, is prevalent in disk-based and distributed hashes, where resizing is prohibitively costly.</p>
<h3><span class="mw-headline" id="Ordered_retrieval_issue">Ordered retrieval issue</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=13" title="Edit section: Ordered retrieval issue">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Hash tables store data in pseudo-random locations, so accessing the data in a sorted manner is a very time consuming operation. Other data structures such as <a href="/w/index.php?title=Self-balancing_binary_search_tree&amp;action=edit&amp;redlink=1" class="new" title="Self-balancing binary search tree (does not exist)">self-balancing binary search trees</a> generally operate more slowly (since their lookup time is O(log <i>n</i>)) and are rather more complex to implement than hash tables but maintain a sorted data structure at all times. See <a href="/w/index.php?title=Associative_array&amp;action=edit&amp;redlink=1" class="new" title="Associative array (does not exist)">a comparison of hash tables and self-balancing binary search trees</a>.</p>
<h3><span class="mw-headline" id="Problems_with_hash_tables">Problems with hash tables</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=14" title="Edit section: Problems with hash tables">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Although hash table lookups use constant time on average, the time spent can be significant. Evaluating a good hash function can be a slow operation. In particular, if simple array indexing can be used instead, this is usually faster.</p>
<p>Hash tables in general exhibit poor <a href="/w/index.php?title=Locality_of_reference&amp;action=edit&amp;redlink=1" class="new" title="Locality of reference (does not exist)">locality of reference</a>â€”that is, the data to be accessed is distributed seemingly at random in memory. Because hash tables cause access patterns that jump around, this can trigger <a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;redlink=1" class="new" title="CPU cache (does not exist)">microprocessor cache</a> misses that cause long delays. Compact data structures such as arrays, searched with <a href="/w/index.php?title=Linear_search&amp;action=edit&amp;redlink=1" class="new" title="Linear search (does not exist)">linear search</a>, may be faster if the table is relatively small and keys are cheap to compare, such as with simple integer keys. According to <a href="/w/index.php?title=Moore%27s_Law&amp;action=edit&amp;redlink=1" class="new" title="Moore's Law (does not exist)">Moore's Law</a>, cache sizes are growing exponentially and so what is considered "small" may be increasing. The optimal performance point varies from system to system; for example, a trial on <a href="/w/index.php?title=Parrot_virtual_machine&amp;action=edit&amp;redlink=1" class="new" title="Parrot virtual machine (does not exist)">Parrot</a> shows that its hash tables outperform linear search in all but the most trivial cases (one to three entries).</p>
<p>More significantly, hash tables are more difficult and error-prone to write and use. Hash tables require the design of an effective hash function for each key type, which in many situations is more difficult and time-consuming to design and debug than the mere comparison function required for a <a href="/w/index.php?title=Self-balancing_binary_search_tree&amp;action=edit&amp;redlink=1" class="new" title="Self-balancing binary search tree (does not exist)">self-balancing binary search tree</a>. In open-addressed hash tables it's even easier to create a poor hash function.</p>
<p>Additionally, in some applications, a <a href="/w/index.php?title=Black_hat&amp;action=edit&amp;redlink=1" class="new" title="Black hat (does not exist)">black hat</a> with knowledge of the hash function may be able to supply information to a hash which creates worst-case behavior by causing excessive collisions, resulting in very poor performance (i.e., a <a href="/w/index.php?title=Denial_of_service_attack&amp;action=edit&amp;redlink=1" class="new" title="Denial of service attack (does not exist)">denial of service attack</a>). In critical applications, either <a href="/w/index.php?title=Universal_hashing&amp;action=edit&amp;redlink=1" class="new" title="Universal hashing (does not exist)">universal hashing</a> can be used or a data structure with better worst-case guarantees may be preferable. For details, see Crosby and Wallach's <i><a rel="nofollow" class="external text" href="http://www.cs.rice.edu/~scrosby/hash/CrosbyWallach_UsenixSec2003.pdf">Denial of Service via Algorithmic Complexity Attacks</a></i>.</p>
<h3><span class="mw-headline" id="Other_hash_table_algorithms">Other hash table algorithms</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=15" title="Edit section: Other hash table algorithms">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p><b>Extendible hashing</b> and <b>linear hashing</b> are hash algorithms that are used in the context of database algorithms used for instance in index file structures, and even primary file organization for a database. Generally, in order to make search scalable for large databases, the search time should be proportional log N or near constant, where N is the number of records to search. Log N searches can be implemented with tree structures, because the degree of fan out and the shortness of the tree relates to the number of steps needed to find a record, so the height of the tree is the maximum number of disc accesses it takes to find where a record is. However, hash tables are also used, because the cost of a disk access can be counted in units of disc accesses, and often that unit is a block of data. Since a hash table can, in the best case, find a key with one or two accesses, a hash table index is regarded as generally faster when retrieving a collection of records during a join operation e.g.</p>
<pre>
SELECT * from customer, orders where customer.cust_id = orders.cust_id and cust_id = X
</pre>
<p>i.e. If orders has a hash index on cust_id, then it takes constant time to locate the block that contains record locations for orders matching cust_id = X. (although, it would be better if the value type of orders was a list of order ids, so that hash keys are just one unique cust_id for each batch of orders, to avoid unnecessary collisions).</p>
<p>Extendible hashing and linear hashing have certain similarities: collisions are accepted as inevitable and are part of the algorithm where blocks or buckets of collision space is added&#160;; traditional good hash function ranges are required, but the hash value is transformed by a dynamic address function&#160;: in <b>extendible hashing</b>, a bit mask is used to mask out unwanted bits, but this mask length increases by one periodically, doubling the available addressing space&#160;; also in extendible hashing, there is an indirection with a directory address space, the directory entries being paired with another address (a pointer ) to the actual block containing the key-value pairs; the entries in the directory correspond to the bit masked hash value (so that the number of entries is equal to maximum bit mask value + 1 e.g. a bit mask of 2 bits, can address a directory of 00 01 10 11, or 3 + 1 = 4).</p>
<p>In <b>linear hashing</b>, the traditional hash value is also masked with a bit mask, but if the resultant smaller hash value falls below a 'split' variable, the original hash value is masked with a bit mask of one bit greater length, making the resultant hash value address recently added blocks. The split variable ranges incrementally between 0 and the maximum current bit mask value e.g. a bit mask of 2, or in the terminology of linear hashing, a "level" of 2, the split variable will range between 0 to 3. When the split variable reaches 4, the level increases by 1, so in the next round of the split variable, it will range between 0 to 7, and reset again when it reaches 8.</p>
<p>The split variable incrementally allows increased addressing space, as new blocks are added; the decision to add a new block occurs whenever a key-and=value is being inserted, and overflows the particular block the key-and-value's key hashes into. This overflow location may be completely unrelated to the block going to be split pointed to by the split variable. However, over time, it is expected that given a good random hash function that distributes entries fairly evenly amongst all addressable blocks, the blocks that actually require splitting because they have overflowed get their turn in round-robin fashion as the split value ranges between 0 - N where N has a factor of 2 to the power of Level, level being the variable incremented whenever the split variable hits N.</p>
<p>New blocks are added one at a time with both extendible hashing, and with linear hashing.</p>
<p>In <b>extendible hashing</b>, a block overflow ( a new key-value colliding with B other key-values, where B is the size of a block) is handled by checking the size of the bit mask "locally", called the "local depth", an attribute which must be stored with the block. The directory structure, also has a depth, the "global depth". If the local depth is less than the global depth, then the local depth is incremented, and all the key values are rehashed and passed through a bit mask which is one bit longer now, placing them either in the current block, or in another block. If the other block happens to be the same block when looked up in the directory, a new block is added, and the directory entry for the other block is made to point to the new block. Why does the directory have entries where two entries point to the same block&#160;? This is because if the local depth <b>is equal to</b> the global depth of the directory, this means the bit mask of the directory does not have enough bits to deal with an increment in the bit mask length of the block, and so the directory must have its bit mask length incremented, but this means the directory now doubles the number of addressable entries. Since half the entries addressable don't exist, the directory simply copies the pointers over to the new entries e.g. if the directory had entries for 00, 01, 10, 11, or a 2 bit mask, and it becomes a 3 bit mask, then 000 001 010 011 100 101 110 111 become the new entries, and 00's block address go to 000 and 001&#160;; 01's pointer goes to 010 and 011, 10 goes to 100 and 101 and so on. And so this creates the situation where two directory entries point to the same block. Although the block that was going to overflow, now can add a new block by redirecting the second pointer to a newly appended block, the other original blocks will have two pointers to them. When it is their turn to split, the algorithm will check local vs global depth and this time find that the local depth is less, and hence no directory splitting is required, only a new block be appended, and the second directory pointer moved from addressing the previous block to addressing the new block.</p>
<p>In <b>linear hashing</b>, adding a similarly hashed block does not occurs immediately when a block overflows, and therefore an overflow block is created to be attached to the overflowing block. However, a block overflow is a signal that more space will be required, and this happens by splitting the block pointed to by the "split" variable, which is initially zero, and hence initially points to block zero. The splitting is done by taking all the key-value pairs in the splitting block, and its overflow block(s), hashing the keys again, but with a bit mask of length current level + 1. This will result in two block addresses, some will be the old block number, and others will be</p>
<pre>
a2 = old block number + ( N times 2 ^ (level) )
</pre>
<dl>
<dt>Rationale</dt>
</dl>
<p>Let m = N times 2 ^ level&#160;; if h is the original hash value, and old block number = h mod m, and now the new block number is h mod ( m * 2 ), because m * 2 = N times 2 ^ (level+1), then the new block number is either h mod m if (h / m) is even so dividing h/m by 2 leaves a zero remainder and therefore doesn't change the remainder, or the new block number is ( h mod m ) + m because h / m is an odd number, and dividing h / m by 2 will leave an excess remainder of m, + the original remainder. ( The same rationale applies to extendible hashing depth incrementing ).</p>
<p>As above, a new block is created with a number a2, which will usually occur at +1 the previous a2 value. Once this is done, the split variable is incremented, so that the next a2 value will be again old a2 + 1. In this way, each block is covered by the split variable eventually, so each block is preemptively rehashed into extra space, and new blocks are added incrementally. Overflow blocks that are no longer needed are discarded, for later garbage collection if needed, or put on an available free block list by chaining.</p>
<p>When the split variable reaches ( N times 2 ^ level ), level is incremented and split variable is reset to zero. In this next round, the split variable will now traverse from zero to ( N times 2 ^ (old_level + 1 ) ), which is exactly the number of blocks at the start of the previous round, but including all the blocks created by the previous round.</p>
<h4><span class="mw-headline" id="A_simple_inference_on_file_storage_mapping_of_linear_hashing_and_extendible_hashing">A simple inference on file storage mapping of linear hashing and extendible hashing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=16" title="Edit section: A simple inference on file storage mapping of linear hashing and extendible hashing">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>As can be seen, extendible hashing requires space to store a directory which can double in size.</p>
<p>Since the space of both algorithms increase by one block at a time, if blocks have a known maximum size or fixed size, then it is straight forward to map the blocks as blocks sequentially appended to a file.</p>
<p>In extendible hashing, it would be logical to store the directory as a separate file, as doubling can be accommodated by adding to the end of the directory file. The separate block file would not have to change, other than have blocks appended to its end.</p>
<p>Header information for linear hashing doesn't increase in size&#160;: basically just the values for N, level, and split need to be recorded, so these can be incorporated as a header into a fixed block size linear hash storage file.</p>
<p>However, linear hashing requires space for overflow blocks, and this might best be stored in another file, otherwise addressing blocks in the linear hash file is not as straight forward as multiplying the block number by the block size and adding the space for N,level, and split.</p>
<p><br />
In the next section, a complete example of linear hashing in Java is given, using a in memory implementation of linear hashing, and code to manage blocks as files in a file directory, the whole contents of the file directory representing the persistent linear hashing structure.</p>
<h3><span class="mw-headline" id="Implementations">Implementations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=17" title="Edit section: Implementations">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>While many programming languages already provide hash table functionality (see <i><a href="/w/index.php?title=Associative_array&amp;action=edit&amp;redlink=1" class="new" title="Associative array (does not exist)">language support for associative arrays</a></i>), there are several independent implementations worth mentioning.</p>
<ul>
<li><a rel="nofollow" class="external text" href="http://goog-sparsehash.sourceforge.net/">Google Sparse Hash</a> The Google SparseHash project contains several hash-map implementations in use at Google, with different performance characteristics, including an implementation that optimizes for space and one that optimizes for speed. The memory-optimized one is extremely memory-efficient with only 2 bits/entry of overhead.</li>
<li><a rel="nofollow" class="external text" href="https://launchpad.net/libmct">MCT</a> provides hashtables similar to Google's <code>dense_hash_map</code>, but without restriction on contained values; it also comes with exception safety and support for C++0x features.</li>
<li>A number of runtime languages and/or standard libraries use hash tables to implement their support for associative arrays because of their efficiency.</li>
</ul>
<h4><span class="mw-headline" id="A_python_implementation_of_extendible_hashing">A python implementation of extendible hashing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=18" title="Edit section: A python implementation of extendible hashing">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The file - block management routines aren't there, so this could be added in to make this a real implementation of a database hash index.</p>
<p>A full page is split according to the (local depth)th bit, first by collecting all the directory indices pointing to the full page, updating the pointers according to the d bit being 0 or 1 corresponding to first and second new pages, then reloading all the key-values after hashing each key and using the d bit of each hash to see which page to allocate to. The local depth of each new page is one greater than the old page's local depth, so that the next d bit can be used next time when splitting.</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="python source-python">
<pre class="de1">
PAGE_SZ <span class="sy0">=</span> <span class="nu0">20</span>
 
<span class="kw1">class</span> Page:
 
        <span class="kw1">def</span> <span class="kw4">__init__</span><span class="br0">(</span><span class="kw2">self</span><span class="br0">)</span>:
                <span class="kw2">self</span>.<span class="me1">m</span> <span class="sy0">=</span> <span class="br0">{</span><span class="br0">}</span>
                <span class="kw2">self</span>.<span class="me1">d</span> <span class="sy0">=</span> <span class="nu0">0</span>
 
        <span class="kw1">def</span> full<span class="br0">(</span><span class="kw2">self</span><span class="br0">)</span>:
                <span class="kw1">return</span> <span class="kw2">len</span><span class="br0">(</span><span class="kw2">self</span>.<span class="me1">m</span><span class="br0">)</span> <span class="sy0">&gt;</span> PAGE_SZ 
 
        <span class="kw1">def</span> put<span class="br0">(</span><span class="kw2">self</span><span class="sy0">,</span>k<span class="sy0">,</span>v<span class="br0">)</span>:
                <span class="kw2">self</span>.<span class="me1">m</span><span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">=</span> v
 
        <span class="kw1">def</span> get<span class="br0">(</span><span class="kw2">self</span><span class="sy0">,</span>k<span class="br0">)</span>:
                <span class="kw1">return</span> <span class="kw2">self</span>.<span class="me1">m</span>.<span class="me1">get</span><span class="br0">(</span>k<span class="br0">)</span>
 
<span class="kw1">class</span> EH:
 
        <span class="kw1">def</span> <span class="kw4">__init__</span><span class="br0">(</span><span class="kw2">self</span><span class="br0">)</span>:
                <span class="kw2">self</span>.<span class="me1">gd</span> <span class="sy0">=</span> <span class="nu0">0</span> 
                p <span class="sy0">=</span> Page<span class="br0">(</span><span class="br0">)</span>
                <span class="kw2">self</span>.<span class="me1">pp</span><span class="sy0">=</span> <span class="br0">[</span>p<span class="br0">]</span>
 
        <span class="kw1">def</span> get_page<span class="br0">(</span><span class="kw2">self</span><span class="sy0">,</span>k<span class="br0">)</span>:
                h <span class="sy0">=</span> <span class="kw2">hash</span><span class="br0">(</span>k<span class="br0">)</span> 
                p <span class="sy0">=</span> <span class="kw2">self</span>.<span class="me1">pp</span><span class="br0">[</span> h &amp; <span class="br0">(</span><span class="br0">(</span> <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> <span class="kw2">self</span>.<span class="me1">gd</span><span class="br0">)</span> -<span class="nu0">1</span><span class="br0">)</span><span class="br0">]</span>
                <span class="kw1">return</span> p                
 
        <span class="kw1">def</span>  put<span class="br0">(</span><span class="kw2">self</span><span class="sy0">,</span> k<span class="sy0">,</span> v<span class="br0">)</span>:
                p <span class="sy0">=</span> <span class="kw2">self</span>.<span class="me1">get_page</span><span class="br0">(</span>k<span class="br0">)</span>
                <span class="kw1">if</span> p.<span class="me1">full</span><span class="br0">(</span><span class="br0">)</span> <span class="kw1">and</span> p.<span class="me1">d</span> <span class="sy0">==</span> <span class="kw2">self</span>.<span class="me1">gd</span>:
                        <span class="kw2">self</span>.<span class="me1">pp</span> <span class="sy0">=</span> <span class="kw2">self</span>.<span class="me1">pp</span> + <span class="kw2">self</span>.<span class="me1">pp</span>
                        <span class="kw2">self</span>.<span class="me1">gd</span> +<span class="sy0">=</span> <span class="nu0">1</span>
 
 
                <span class="kw1">if</span> p.<span class="me1">full</span><span class="br0">(</span><span class="br0">)</span> <span class="kw1">and</span> p.<span class="me1">d</span> <span class="sy0">&lt;</span> <span class="kw2">self</span>.<span class="me1">gd</span>:
                        p.<span class="me1">put</span><span class="br0">(</span>k<span class="sy0">,</span>v<span class="br0">)</span><span class="sy0">;</span>
                        p1 <span class="sy0">=</span> Page<span class="br0">(</span><span class="br0">)</span>
                        p2 <span class="sy0">=</span> Page<span class="br0">(</span><span class="br0">)</span>
                        <span class="kw1">for</span> k2 <span class="kw1">in</span> p.<span class="me1">m</span>.<span class="me1">keys</span><span class="br0">(</span><span class="br0">)</span>:
                                v2 <span class="sy0">=</span> p.<span class="me1">m</span><span class="br0">[</span>k2<span class="br0">]</span>
                                h <span class="sy0">=</span> k2.<span class="kw4">__hash__</span><span class="br0">(</span><span class="br0">)</span>
                                h <span class="sy0">=</span> h &amp; <span class="br0">(</span><span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> <span class="kw2">self</span>.<span class="me1">gd</span><span class="br0">)</span> -<span class="nu0">1</span><span class="br0">)</span>
                                <span class="kw1">if</span> <span class="br0">(</span>h | <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> p.<span class="me1">d</span><span class="br0">)</span> <span class="sy0">==</span> h<span class="br0">)</span>:
                                        p2.<span class="me1">put</span><span class="br0">(</span>k2<span class="sy0">,</span>v2<span class="br0">)</span>
                                <span class="kw1">else</span>:
                                        p1.<span class="me1">put</span><span class="br0">(</span>k2<span class="sy0">,</span>v2<span class="br0">)</span>
                        l <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
                        <span class="kw1">for</span> i <span class="kw1">in</span> <span class="kw2">xrange</span><span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span> <span class="kw2">len</span><span class="br0">(</span><span class="kw2">self</span>.<span class="me1">pp</span><span class="br0">)</span><span class="br0">)</span>:
                                <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">pp</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> p:
                                        l.<span class="me1">append</span><span class="br0">(</span>i<span class="br0">)</span>
                        <span class="kw1">for</span> i <span class="kw1">in</span> l:
                                <span class="kw1">if</span> <span class="br0">(</span>i | <span class="br0">(</span> <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> p.<span class="me1">d</span><span class="br0">)</span> <span class="sy0">==</span> i<span class="br0">)</span>:
                                        <span class="kw2">self</span>.<span class="me1">pp</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> p2
 
                                <span class="kw1">else</span>:
                                        <span class="kw2">self</span>.<span class="me1">pp</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> p1
 
                        p1.<span class="me1">d</span> <span class="sy0">=</span> p.<span class="me1">d</span> + <span class="nu0">1</span>
                        p2.<span class="me1">d</span> <span class="sy0">=</span> p1.<span class="me1">d</span>
                <span class="kw1">else</span>:   
                        p.<span class="me1">put</span><span class="br0">(</span>k<span class="sy0">,</span>  v<span class="br0">)</span>
 
        <span class="kw1">def</span> get<span class="br0">(</span><span class="kw2">self</span><span class="sy0">,</span> k<span class="br0">)</span>:
                p <span class="sy0">=</span> <span class="kw2">self</span>.<span class="me1">get_page</span><span class="br0">(</span>k<span class="br0">)</span>
                <span class="kw1">return</span> p.<span class="me1">get</span><span class="br0">(</span>k<span class="br0">)</span>
 
 
 
<span class="kw1">if</span> __name__ <span class="sy0">==</span> <span class="st0">"__main__"</span>:
        eh <span class="sy0">=</span> EH<span class="br0">(</span><span class="br0">)</span>
        N <span class="sy0">=</span> <span class="nu0">10000</span>
        l <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
        <span class="kw1">for</span> i <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span>N<span class="br0">)</span>:    
                l.<span class="me1">append</span><span class="br0">(</span>i<span class="br0">)</span>
 
        <span class="kw1">import</span> <span class="kw3">random</span>
        <span class="kw3">random</span>.<span class="me1">shuffle</span><span class="br0">(</span>l<span class="br0">)</span>
        <span class="kw1">for</span> i <span class="kw1">in</span> l:
                eh.<span class="me1">put</span><span class="br0">(</span>i<span class="sy0">,</span>i<span class="br0">)</span>
        <span class="kw1">print</span> l
 
        <span class="kw1">for</span> i <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span> N<span class="br0">)</span>:
                <span class="kw1">print</span> eh.<span class="me1">get</span><span class="br0">(</span>i<span class="br0">)</span>
</pre></div>
</div>
<h4><span class="mw-headline" id="A_Java_implementation_of_extendible_hashing">A Java implementation of extendible hashing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=19" title="Edit section: A Java implementation of extendible hashing">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>A direct Java translation of the above python code, tested to work.</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="java source-java">
<pre class="de1">
<span class="kw1">package</span> <span class="co2">ext_hashing</span><span class="sy0">;</span>
 
<span class="kw1">import</span> <span class="co2">java.util.ArrayList</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.util.HashMap</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.util.List</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.util.Map</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.util.Random</span><span class="sy0">;</span>
 
<span class="kw1">public</span> <span class="kw1">class</span> EH2<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> <span class="br0">{</span>
        <span class="kw1">static</span> <span class="kw1">class</span> Page<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> <span class="br0">{</span>
                <span class="kw1">static</span> <span class="kw4">int</span> PAGE_SZ <span class="sy0">=</span> <span class="nu0">20</span><span class="sy0">;</span>
                <span class="kw1">private</span> Map<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> m <span class="sy0">=</span> <span class="kw1">new</span> HashMap<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw4">int</span> d <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
 
                <span class="kw4">boolean</span> full<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                        <span class="kw1">return</span> m.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">&gt;</span> PAGE_SZ<span class="sy0">;</span>
                <span class="br0">}</span>
 
                <span class="kw4">void</span> put<span class="br0">(</span>K k, V v<span class="br0">)</span> <span class="br0">{</span>
                        m.<span class="me1">put</span><span class="br0">(</span>k, v<span class="br0">)</span><span class="sy0">;</span>
 
                <span class="br0">}</span>
 
                V get<span class="br0">(</span>K k<span class="br0">)</span> <span class="br0">{</span>
                        <span class="kw1">return</span> m.<span class="me1">get</span><span class="br0">(</span>k<span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
        <span class="br0">}</span>
 
        <span class="kw4">int</span> gd <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
 
        List<span class="sy0">&lt;</span>Page<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;&gt;</span> pp <span class="sy0">=</span> <span class="kw1">new</span> ArrayList<span class="sy0">&lt;</span>Page<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 
        <span class="kw1">public</span> EH2<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                pp.<span class="me1">add</span><span class="br0">(</span><span class="kw1">new</span> Page<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        Page<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> getPage<span class="br0">(</span>K k<span class="br0">)</span> <span class="br0">{</span>
                <span class="kw4">int</span> h <span class="sy0">=</span> k.<span class="me1">hashCode</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                Page<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> p <span class="sy0">=</span> pp.<span class="me1">get</span><span class="br0">(</span>h <span class="sy0">&amp;</span> <span class="br0">(</span><span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> gd<span class="br0">)</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">return</span> p<span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="kw4">void</span> put<span class="br0">(</span>K k, V v<span class="br0">)</span> <span class="br0">{</span>
                Page<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> p <span class="sy0">=</span> getPage<span class="br0">(</span>k<span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">if</span> <span class="br0">(</span>p.<span class="me1">full</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">&amp;&amp;</span> p.<span class="me1">d</span> <span class="sy0">==</span> gd<span class="br0">)</span> <span class="br0">{</span>
                        List<span class="sy0">&lt;</span>Page<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;&gt;</span> pp2 <span class="sy0">=</span> <span class="kw1">new</span> ArrayList<span class="sy0">&lt;</span>EH2.<span class="me1">Page</span><span class="sy0">&lt;</span>K, V<span class="sy0">&gt;&gt;</span><span class="br0">(</span>pp<span class="br0">)</span><span class="sy0">;</span>
                        pp.<span class="me1">addAll</span><span class="br0">(</span>pp2<span class="br0">)</span><span class="sy0">;</span>
                        <span class="sy0">++</span>gd<span class="sy0">;</span>
                <span class="br0">}</span>
 
                <span class="kw1">if</span> <span class="br0">(</span>p.<span class="me1">full</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">&amp;&amp;</span> p.<span class="me1">d</span> <span class="sy0">&lt;</span> gd<span class="br0">)</span> <span class="br0">{</span>
                        p.<span class="me1">put</span><span class="br0">(</span>k, v<span class="br0">)</span><span class="sy0">;</span>
                        Page<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> p1, p2<span class="sy0">;</span>
                        p1 <span class="sy0">=</span> <span class="kw1">new</span> Page<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                        p2 <span class="sy0">=</span> <span class="kw1">new</span> Page<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                        <span class="kw1">for</span> <span class="br0">(</span>K k2 <span class="sy0">:</span> p.<span class="me1">m</span>.<span class="me1">keySet</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
                                V v2 <span class="sy0">=</span> p.<span class="me1">m</span>.<span class="me1">get</span><span class="br0">(</span>k2<span class="br0">)</span><span class="sy0">;</span>
 
                                <span class="kw4">int</span> h <span class="sy0">=</span> k2.<span class="me1">hashCode</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">&amp;</span> <span class="br0">(</span><span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> gd<span class="br0">)</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
 
                                <span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>h <span class="sy0">|</span> <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> p.<span class="me1">d</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">==</span> h<span class="br0">)</span>
                                        p2.<span class="me1">put</span><span class="br0">(</span>k2, v2<span class="br0">)</span><span class="sy0">;</span>
                                <span class="kw1">else</span>
                                        p1.<span class="me1">put</span><span class="br0">(</span>k2, v2<span class="br0">)</span><span class="sy0">;</span>
                        <span class="br0">}</span>
 
                        List<span class="sy0">&lt;</span>Integer<span class="sy0">&gt;</span> l <span class="sy0">=</span> <span class="kw1">new</span> ArrayList<span class="sy0">&lt;</span>Integer<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 
                        <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> pp.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span>
                                <span class="kw1">if</span> <span class="br0">(</span>pp.<span class="me1">get</span><span class="br0">(</span>i<span class="br0">)</span> <span class="sy0">==</span> p<span class="br0">)</span>
                                        l.<span class="me1">add</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
 
                        <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">:</span> l<span class="br0">)</span>
                                <span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>i <span class="sy0">|</span> <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> p.<span class="me1">d</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">==</span> i<span class="br0">)</span>
                                        pp.<span class="me1">set</span><span class="br0">(</span>i, p2<span class="br0">)</span><span class="sy0">;</span>
                                <span class="kw1">else</span>
                                        pp.<span class="me1">set</span><span class="br0">(</span>i, p1<span class="br0">)</span><span class="sy0">;</span>
 
                        p1.<span class="me1">d</span> <span class="sy0">=</span> p.<span class="me1">d</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
                        p2.<span class="me1">d</span> <span class="sy0">=</span> p1.<span class="me1">d</span><span class="sy0">;</span>
 
                <span class="br0">}</span> <span class="kw1">else</span>
                        p.<span class="me1">put</span><span class="br0">(</span>k, v<span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="kw1">public</span> V get<span class="br0">(</span>K k<span class="br0">)</span> <span class="br0">{</span>
                <span class="kw1">return</span> getPage<span class="br0">(</span>k<span class="br0">)</span>.<span class="me1">get</span><span class="br0">(</span>k<span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">void</span> main<span class="br0">(</span><span class="kw3">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
 
                <span class="kw4">int</span> N <span class="sy0">=</span> <span class="nu0">500000</span><span class="sy0">;</span>
 
                <span class="kw3">Random</span> r <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">Random</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                List<span class="sy0">&lt;</span>Integer<span class="sy0">&gt;</span> l <span class="sy0">=</span> <span class="kw1">new</span> ArrayList<span class="sy0">&lt;</span>Integer<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> N<span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> <span class="br0">{</span>
                        l.<span class="me1">add</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
 
                <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> N<span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> <span class="br0">{</span>
                        <span class="kw4">int</span> j <span class="sy0">=</span> r.<span class="me1">nextInt</span><span class="br0">(</span>N<span class="br0">)</span><span class="sy0">;</span>
                        <span class="kw4">int</span> t <span class="sy0">=</span> l.<span class="me1">get</span><span class="br0">(</span>j<span class="br0">)</span><span class="sy0">;</span>
                        l.<span class="me1">set</span><span class="br0">(</span>j, l.<span class="me1">get</span><span class="br0">(</span>i<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                        l.<span class="me1">set</span><span class="br0">(</span>i, t<span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
 
                EH2<span class="sy0">&lt;</span><span class="kw3">Integer</span>, Integer<span class="sy0">&gt;</span> eh <span class="sy0">=</span> <span class="kw1">new</span> EH2<span class="sy0">&lt;</span><span class="kw3">Integer</span>, Integer<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> N<span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> <span class="br0">{</span>
                        eh.<span class="me1">put</span><span class="br0">(</span>l.<span class="me1">get</span><span class="br0">(</span>i<span class="br0">)</span>, l.<span class="me1">get</span><span class="br0">(</span>i<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
 
                <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> N<span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> <span class="br0">{</span>
                        <span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">printf</span><span class="br0">(</span><span class="st0">"%d:%d , "</span>, i, eh.<span class="me1">get</span><span class="br0">(</span>i<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                        <span class="kw1">if</span> <span class="br0">(</span>i <span class="sy0">%</span> <span class="nu0">10</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
                                <span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
 
        <span class="br0">}</span>
<span class="br0">}</span>
</pre></div>
</div>
<h4><span class="mw-headline" id="A_Java_implementation_of_linear_hashing">A Java implementation of linear hashing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=20" title="Edit section: A Java implementation of linear hashing">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>( usable for simple database indexing of arbitrary size, (almost&#160;?) )</p>
<p>This code evolved out of a need for a bigger Java HashMap. Originally, a Java HashMap standard object was used as a Map to index a heap like database file ( DBF format). But then, a file was encountered with so many records that the OutOfMemoryError was being thrown, so linear hashing seemed like a reasonably simple algorithm to use as a disk based index scheme.</p>
<p>Initially, linear hashing was implemented behind the Java Map interface, mainly the put(k,v) and get(k,v) methods. Generics was used, in order not to get too involved in the key and value details.</p>
<h6><span class="mw-headline" id="debugging_to_achieve_functionality">debugging to achieve functionality</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit&amp;section=21" title="Edit section: debugging to achieve functionality">edit</a><span class="mw-editsection-bracket">]</span></span></h6>
<p>Custom dumps to System.err was used to verify that blocks were being created, filled, and overflow blocks were of expected number if they existed ( no. = 1 ). This was all done in a purely in-memory implementation.</p>
<p>Later, the standard Java decoupling was introduced, where the original LHMap2 class accepted listeners to events, such as when a block was needed. The listener was then implemented as a block file manager, loading blocks into the block list of the memory LHMap2 object whenever a null block was encountered on the block list, and checking whether virtual machine runtime free memory was low, and retiring blocks using just a basic first-to-last-listed cache removal algorithm (not least recently used (LRU), not least often used ) by saving them to disk file, and then actively invoking the system garbage collector.</p>
<p>Because an application use case existed, which was to externally index a large DBF table, this use case was used as the main test harness for the algorithm implementation.</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="java source-java">
<pre class="de1">
<span class="kw1">package</span> <span class="co2">linearhashmap</span><span class="sy0">;</span>
 
<span class="kw1">import</span> <span class="co2">java.io.Externalizable</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.io.IOException</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.io.ObjectInput</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.io.ObjectOutput</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.io.Serializable</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.util.ArrayList</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.util.Collection</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.util.Iterator</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.util.LinkedList</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.util.List</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.util.Map</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.util.Set</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.util.TreeMap</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.util.TreeSet</span><span class="sy0">;</span>
 
<span class="co3">/**
 * 
 * @param &lt;K&gt;
 *            key type , must implement equals() and hashCode()
 * @param &lt;V&gt;
 *            value type
 * 
 * 
 */</span>
<span class="kw1">public</span> <span class="kw1">class</span> LHMap2<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> <span class="kw1">implements</span> Map<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span>, <span class="kw3">Serializable</span> <span class="br0">{</span>
 
        <span class="co3">/**
         * 
         */</span>
        <span class="kw1">private</span> <span class="kw1">static</span> <span class="kw1">final</span> <span class="kw4">long</span> serialVersionUID <span class="sy0">=</span> 3095071852466632996L<span class="sy0">;</span>
 
        <span class="co3">/**
         * 
         */</span>
 
        <span class="kw1">public</span> <span class="kw1">static</span> <span class="kw1">interface</span> BlockListener<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> <span class="br0">{</span>
                <span class="kw1">public</span> <span class="kw4">void</span> blockRequested<span class="br0">(</span><span class="kw4">int</span> block, LHMap2<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> map<span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        List<span class="sy0">&lt;</span>BlockListener<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;&gt;</span> listeners <span class="sy0">=</span> <span class="kw1">new</span> ArrayList<span class="sy0">&lt;</span>BlockListener<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 
        <span class="co1">// int savedBlocks;</span>
        <span class="kw4">int</span> N<span class="sy0">;</span>
        <span class="kw4">int</span> level <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
        <span class="kw4">int</span> split <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
        <span class="kw4">int</span> blockSize<span class="sy0">;</span>
        <span class="kw4">long</span> totalWrites <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
 
        List<span class="sy0">&lt;</span>Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;&gt;</span> blockList <span class="sy0">=</span> <span class="kw1">new</span> ArrayList<span class="sy0">&lt;</span>Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 
        <span class="kw1">public</span> <span class="kw4">void</span> addBlockListener<span class="br0">(</span>BlockListener<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> listener<span class="br0">)</span> <span class="br0">{</span>
                listeners.<span class="me1">add</span><span class="br0">(</span>listener<span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="kw4">void</span> notifyBlockRequested<span class="br0">(</span><span class="kw4">int</span> block<span class="br0">)</span> <span class="br0">{</span>
                <span class="kw1">for</span> <span class="br0">(</span>BlockListener<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> l <span class="sy0">:</span> listeners<span class="br0">)</span> <span class="br0">{</span>
                        l.<span class="me1">blockRequested</span><span class="br0">(</span>block, <span class="kw1">this</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
        <span class="br0">}</span>
 
        <span class="kw1">public</span> LHMap2<span class="br0">(</span><span class="kw4">int</span> blockSize, <span class="kw4">int</span> nStartingBlocks<span class="br0">)</span> <span class="br0">{</span>
                <span class="kw1">this</span>.<span class="me1">blockSize</span> <span class="sy0">=</span> blockSize<span class="sy0">;</span>
                <span class="kw1">this</span>.<span class="me1">N</span> <span class="sy0">=</span> nStartingBlocks<span class="sy0">;</span>
                <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> nStartingBlocks<span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> <span class="br0">{</span>
                        addBlock<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
 
                <span class="kw3">Runtime</span>.<span class="me1">getRuntime</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">addShutdownHook</span><span class="br0">(</span><span class="kw1">new</span> <span class="kw3">Thread</span><span class="br0">(</span><span class="kw1">new</span> <span class="kw3">Runnable</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
 
                        @Override
                        <span class="kw1">public</span> <span class="kw4">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                                showStructure<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 
                        <span class="br0">}</span>
                <span class="br0">}</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="kw1">public</span> <span class="kw1">static</span> <span class="kw1">class</span> Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> <span class="kw1">implements</span> <span class="kw3">Externalizable</span> <span class="br0">{</span>
                <span class="co3">/**
                 * 
                 */</span>
 
                <span class="kw4">int</span> j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
 
                Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> overflow <span class="sy0">=</span> <span class="kw2">null</span><span class="sy0">;</span>
                LinkedList<span class="sy0">&lt;</span>K<span class="sy0">&gt;</span> keyList <span class="sy0">=</span> <span class="kw1">new</span> LinkedList<span class="sy0">&lt;</span>K<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                LinkedList<span class="sy0">&lt;</span>V<span class="sy0">&gt;</span> valueList <span class="sy0">=</span> <span class="kw1">new</span> LinkedList<span class="sy0">&lt;</span>V<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">transient</span> <span class="kw1">private</span> LHMap2<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> owner<span class="sy0">;</span>
                <span class="kw1">transient</span> <span class="kw1">private</span> Map<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> shadow <span class="sy0">=</span> <span class="kw1">new</span> TreeMap<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 
                <span class="kw1">private</span> <span class="kw4">boolean</span> changed <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span>
 
                <span class="kw1">private</span> <span class="kw4">int</span> size <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
 
                <span class="kw1">public</span> LHMap2<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> getOwner<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                        <span class="kw1">return</span> owner<span class="sy0">;</span>
                <span class="br0">}</span>
 
                <span class="kw1">public</span> <span class="kw4">void</span> setOwner<span class="br0">(</span>LHMap2<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> owner<span class="br0">)</span> <span class="br0">{</span>
                        <span class="kw1">this</span>.<span class="me1">owner</span> <span class="sy0">=</span> owner<span class="sy0">;</span>
                        Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> ov <span class="sy0">=</span> overflow<span class="sy0">;</span>
                        <span class="kw1">while</span> <span class="br0">(</span>ov <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">)</span> <span class="br0">{</span>
                                overflow.<span class="me1">setOwner</span><span class="br0">(</span>owner<span class="br0">)</span><span class="sy0">;</span>
                                ov <span class="sy0">=</span> ov.<span class="me1">overflow</span><span class="sy0">;</span>
                        <span class="br0">}</span>
                <span class="br0">}</span>
 
                <span class="kw1">public</span> Block<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                        <span class="kw1">super</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
 
                <span class="kw1">public</span> Block<span class="br0">(</span>LHMap2<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> map<span class="br0">)</span> <span class="br0">{</span>
                        setOwner<span class="br0">(</span>map<span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
 
                <span class="kw1">public</span> V put<span class="br0">(</span>K k, V v<span class="br0">)</span> <span class="br0">{</span>
                        setChanged<span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span><span class="sy0">;</span>
 
                        V v2 <span class="sy0">=</span> replace<span class="br0">(</span>k, v<span class="br0">)</span><span class="sy0">;</span>
                        <span class="kw1">if</span> <span class="br0">(</span>v2 <span class="sy0">==</span> <span class="kw2">null</span><span class="br0">)</span> <span class="br0">{</span>
                                <span class="sy0">++</span>size<span class="sy0">;</span>
                                <span class="kw1">if</span> <span class="br0">(</span>keyList.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">==</span> getOwner<span class="br0">(</span><span class="br0">)</span>.<span class="me1">blockSize</span><span class="br0">)</span> <span class="br0">{</span>
 
                                        <span class="kw1">if</span> <span class="br0">(</span>overflow <span class="sy0">==</span> <span class="kw2">null</span><span class="br0">)</span> <span class="br0">{</span>
                                                getOwner<span class="br0">(</span><span class="br0">)</span>.<span class="me1">blockOverflowed</span><span class="br0">(</span><span class="kw1">this</span>, k, v<span class="br0">)</span><span class="sy0">;</span>
                                        <span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
                                                overflow.<span class="me1">put</span><span class="br0">(</span>k, v<span class="br0">)</span><span class="sy0">;</span>
                                        <span class="br0">}</span>
 
                                <span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
                                        keyList.<span class="me1">addFirst</span><span class="br0">(</span>k<span class="br0">)</span><span class="sy0">;</span>
                                        valueList.<span class="me1">addFirst</span><span class="br0">(</span>v<span class="br0">)</span><span class="sy0">;</span>
                                <span class="br0">}</span>
 
                        <span class="br0">}</span>
 
                        <span class="kw1">return</span> v2<span class="sy0">;</span>
                <span class="br0">}</span>
 
                <span class="kw4">void</span> setChanged<span class="br0">(</span><span class="kw4">boolean</span> b<span class="br0">)</span> <span class="br0">{</span>
                        changed <span class="sy0">=</span> b<span class="sy0">;</span>
                <span class="br0">}</span>
 
                <span class="kw1">public</span> Map<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> drainToMap<span class="br0">(</span>Map<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> map<span class="br0">)</span> <span class="br0">{</span>
 
                        <span class="kw1">while</span> <span class="br0">(</span><span class="sy0">!</span>keyList.<span class="me1">isEmpty</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
                                K k <span class="sy0">=</span> keyList.<span class="me1">removeLast</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                                V v <span class="sy0">=</span> valueList.<span class="me1">removeLast</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                                map.<span class="me1">put</span><span class="br0">(</span>k, v<span class="br0">)</span><span class="sy0">;</span>
 
                        <span class="br0">}</span>
 
                        <span class="kw1">if</span> <span class="br0">(</span>overflow <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">)</span>
 
                                map <span class="sy0">=</span> overflow.<span class="me1">drainToMap</span><span class="br0">(</span>map<span class="br0">)</span><span class="sy0">;</span>
 
                        garbageCollectionOverflow<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 
                        <span class="kw1">return</span> map<span class="sy0">;</span>
                <span class="br0">}</span>
 
                <span class="kw1">public</span> <span class="kw4">void</span> updateMap<span class="br0">(</span>Map<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> map<span class="br0">)</span> <span class="br0">{</span>
                        Iterator<span class="sy0">&lt;</span>K<span class="sy0">&gt;</span> ik <span class="sy0">=</span> keyList.<span class="me1">descendingIterator</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                        Iterator<span class="sy0">&lt;</span>V<span class="sy0">&gt;</span> iv <span class="sy0">=</span> valueList.<span class="me1">descendingIterator</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                        <span class="kw1">while</span> <span class="br0">(</span>ik.<span class="me1">hasNext</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">&amp;&amp;</span> iv.<span class="me1">hasNext</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
                                map.<span class="me1">put</span><span class="br0">(</span>ik.<span class="me1">next</span><span class="br0">(</span><span class="br0">)</span>, iv.<span class="me1">next</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                        <span class="br0">}</span>
 
                        <span class="kw1">if</span> <span class="br0">(</span>overflow <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">)</span>
                                overflow.<span class="me1">updateMap</span><span class="br0">(</span>map<span class="br0">)</span><span class="sy0">;</span>
 
                <span class="br0">}</span>
 
                <span class="kw1">private</span> <span class="kw4">void</span> garbageCollectionOverflow<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                        <span class="kw1">if</span> <span class="br0">(</span>overflow <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">)</span> <span class="br0">{</span>
                                overflow.<span class="me1">garbageCollectionOverflow</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                                overflow <span class="sy0">=</span> <span class="kw2">null</span><span class="sy0">;</span>
 
                        <span class="br0">}</span>
                <span class="br0">}</span>
 
                <span class="kw1">public</span> <span class="kw4">void</span> addOverflowBucket<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
 
                        <span class="co1">// assert overflow is needed</span>
                        <span class="kw1">if</span> <span class="br0">(</span>keyList.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">&lt;</span> getOwner<span class="br0">(</span><span class="br0">)</span>.<span class="me1">blockSize</span><span class="br0">)</span>
                                <span class="kw1">return</span><span class="sy0">;</span>
 
                        <span class="kw1">if</span> <span class="br0">(</span>overflow <span class="sy0">==</span> <span class="kw2">null</span><span class="br0">)</span> <span class="br0">{</span>
                                overflow <span class="sy0">=</span> <span class="kw1">new</span> Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span><span class="br0">(</span>getOwner<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                        <span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
                                overflow.<span class="me1">addOverflowBucket</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                        <span class="br0">}</span>
                <span class="br0">}</span>
 
                <span class="kw1">public</span> V replace<span class="br0">(</span>K key, V v2<span class="br0">)</span> <span class="br0">{</span>
 
                        <span class="kw1">if</span> <span class="br0">(</span>overflow <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">)</span> <span class="br0">{</span>
                                V v <span class="sy0">=</span> overflow.<span class="me1">replace</span><span class="br0">(</span>key, v2<span class="br0">)</span><span class="sy0">;</span>
                                <span class="kw1">if</span> <span class="br0">(</span>v <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">)</span>
                                        <span class="kw1">return</span> v<span class="sy0">;</span>
                        <span class="br0">}</span>
 
                        Iterator<span class="sy0">&lt;</span>K<span class="sy0">&gt;</span> i <span class="sy0">=</span> keyList.<span class="me1">listIterator</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 
                        <span class="kw4">int</span> j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
 
                        <span class="kw1">while</span> <span class="br0">(</span>i.<span class="me1">hasNext</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
 
                                <span class="kw1">if</span> <span class="br0">(</span>key.<span class="me1">equals</span><span class="br0">(</span>i.<span class="me1">next</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
 
                                        V v <span class="sy0">=</span> valueList.<span class="me1">get</span><span class="br0">(</span>j<span class="br0">)</span><span class="sy0">;</span>
 
                                        <span class="kw1">if</span> <span class="br0">(</span>v2 <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">)</span> <span class="br0">{</span>
 
                                                valueList.<span class="me1">set</span><span class="br0">(</span>j, v2<span class="br0">)</span><span class="sy0">;</span>
 
                                        <span class="br0">}</span>
 
                                        <span class="kw1">return</span> v<span class="sy0">;</span>
                                <span class="br0">}</span>
                                <span class="sy0">++</span>j<span class="sy0">;</span>
                        <span class="br0">}</span>
 
                        <span class="kw1">return</span> <span class="kw2">null</span><span class="sy0">;</span>
                <span class="br0">}</span>
 
                <span class="kw1">public</span> <span class="kw4">boolean</span> isChanged<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                        <span class="kw1">return</span> changed<span class="sy0">;</span>
                <span class="br0">}</span>
 
                @Override
                <span class="kw1">public</span> <span class="kw4">void</span> readExternal<span class="br0">(</span><span class="kw3">ObjectInput</span> arg0<span class="br0">)</span> <span class="kw1">throws</span> <span class="kw3">IOException</span>,
                                <span class="kw3">ClassNotFoundException</span> <span class="br0">{</span>
                        <span class="kw4">int</span> sz <span class="sy0">=</span> arg0.<span class="me1">readInt</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                        <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> sz<span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> <span class="br0">{</span>
                                K k <span class="sy0">=</span> <span class="br0">(</span>K<span class="br0">)</span> arg0.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                                V v <span class="sy0">=</span> <span class="br0">(</span>V<span class="br0">)</span> arg0.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                                shadow.<span class="me1">put</span><span class="br0">(</span>k, v<span class="br0">)</span><span class="sy0">;</span>
                        <span class="br0">}</span>
                <span class="br0">}</span>
 
                <span class="kw1">public</span> <span class="kw4">void</span> loadFromShadow<span class="br0">(</span>LHMap2<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> owner<span class="br0">)</span> <span class="br0">{</span>
                        setOwner<span class="br0">(</span>owner<span class="br0">)</span><span class="sy0">;</span>
                        Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> b <span class="sy0">=</span> <span class="kw1">this</span><span class="sy0">;</span>
                        <span class="kw1">for</span> <span class="br0">(</span>K k <span class="sy0">:</span> shadow.<span class="me1">keySet</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
                                <span class="kw1">if</span> <span class="br0">(</span>b.<span class="me1">keyList</span>.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">==</span> owner.<span class="me1">blockSize</span><span class="br0">)</span> <span class="br0">{</span>
                                        Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> overflow <span class="sy0">=</span> <span class="kw1">new</span> Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span><span class="br0">(</span>owner<span class="br0">)</span><span class="sy0">;</span>
                                        b.<span class="me1">overflow</span> <span class="sy0">=</span> overflow<span class="sy0">;</span>
                                        b <span class="sy0">=</span> overflow<span class="sy0">;</span>
                                <span class="br0">}</span>
                                b.<span class="me1">keyList</span>.<span class="me1">add</span><span class="br0">(</span>k<span class="br0">)</span><span class="sy0">;</span>
                                b.<span class="me1">valueList</span>.<span class="me1">add</span><span class="br0">(</span>shadow.<span class="me1">get</span><span class="br0">(</span>k<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
 
                        <span class="br0">}</span>
                        shadow.<span class="me1">clear</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
 
                @Override
                <span class="kw1">public</span> <span class="kw4">void</span> writeExternal<span class="br0">(</span><span class="kw3">ObjectOutput</span> arg0<span class="br0">)</span> <span class="kw1">throws</span> <span class="kw3">IOException</span> <span class="br0">{</span>
                        <span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>changed<span class="br0">)</span>
                                <span class="kw1">return</span><span class="sy0">;</span>
                        Map<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> map <span class="sy0">=</span> <span class="kw1">new</span> TreeMap<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 
                        updateMap<span class="br0">(</span>map<span class="br0">)</span><span class="sy0">;</span>
                        <span class="kw4">int</span> sz <span class="sy0">=</span> map.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                        arg0.<span class="me1">writeInt</span><span class="br0">(</span>sz<span class="br0">)</span><span class="sy0">;</span>
                        <span class="kw1">for</span> <span class="br0">(</span>K k <span class="sy0">:</span> map.<span class="me1">keySet</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
                                arg0.<span class="me1">writeObject</span><span class="br0">(</span>k<span class="br0">)</span><span class="sy0">;</span>
                                arg0.<span class="me1">writeObject</span><span class="br0">(</span>map.<span class="me1">get</span><span class="br0">(</span>k<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                        <span class="br0">}</span>
                        setChanged<span class="br0">(</span><span class="kw2">false</span><span class="br0">)</span><span class="sy0">;</span>
 
                <span class="br0">}</span>
 
        <span class="br0">}</span>
 
        <span class="kw4">void</span> init<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
 
                <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> N<span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> <span class="br0">{</span>
                        addBlock<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
        <span class="br0">}</span>
 
        <span class="co3">/**
         * @param hashValue
         * @return a bucket number.
         */</span>
        <span class="kw4">int</span> getDynamicHash<span class="br0">(</span><span class="kw4">int</span> hashValue<span class="br0">)</span> <span class="br0">{</span>
 
                <span class="kw4">long</span> unsignedHash <span class="sy0">=</span> <span class="br0">(</span><span class="br0">(</span><span class="kw4">long</span><span class="br0">)</span> hashValue <span class="sy0">&lt;&lt;</span> <span class="nu0">32</span><span class="br0">)</span> <span class="sy0">&gt;&gt;&gt;</span> <span class="nu0">32</span><span class="sy0">;</span>
                <span class="co1">// ^^ this long cast needed</span>
                <span class="kw4">int</span> h <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="br0">(</span>unsignedHash <span class="sy0">%</span> <span class="br0">(</span>N <span class="sy0">&lt;&lt;</span> level<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="co1">// System.err.println("h = " + h);</span>
                <span class="kw1">if</span> <span class="br0">(</span>h <span class="sy0">&lt;</span> split<span class="br0">)</span> <span class="br0">{</span>
 
                        h <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="br0">(</span>unsignedHash <span class="sy0">%</span> <span class="br0">(</span>N <span class="sy0">&lt;&lt;</span> <span class="br0">(</span>level <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                        <span class="co1">// System.err.println("h &lt; split, new h = " + h);</span>
                <span class="br0">}</span>
                <span class="kw1">return</span> h<span class="sy0">;</span>
 
        <span class="br0">}</span>
 
        @Override
        <span class="kw1">public</span> V put<span class="br0">(</span>K k, V v<span class="br0">)</span> <span class="br0">{</span>
                <span class="sy0">++</span>totalWrites<span class="sy0">;</span>
                <span class="kw4">int</span> h <span class="sy0">=</span> getDynamicHash<span class="br0">(</span>k.<span class="me1">hashCode</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> b <span class="sy0">=</span> getBlock<span class="br0">(</span>h<span class="br0">)</span><span class="sy0">;</span>
 
                b.<span class="me1">put</span><span class="br0">(</span>k, v<span class="br0">)</span><span class="sy0">;</span>
 
                <span class="kw1">return</span> v<span class="sy0">;</span>
 
        <span class="br0">}</span>
 
        <span class="kw1">public</span> <span class="kw4">long</span> getTotalWrites<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                <span class="kw1">return</span> totalWrites<span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="kw1">private</span> Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> getBlock<span class="br0">(</span><span class="kw4">int</span> h<span class="br0">)</span> <span class="br0">{</span>
                notifyBlockRequested<span class="br0">(</span>h<span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">return</span> blockList.<span class="me1">get</span><span class="br0">(</span>h<span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="kw4">void</span> blockOverflowed<span class="br0">(</span>Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> b, K k, V v<span class="br0">)</span> <span class="br0">{</span>
 
                splitNextBucket<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 
                b.<span class="me1">addOverflowBucket</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                b.<span class="me1">put</span><span class="br0">(</span>k, v<span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="kw1">private</span> <span class="kw4">void</span> splitNextBucket<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> b <span class="sy0">=</span> getBlock<span class="br0">(</span>split<span class="br0">)</span><span class="sy0">;</span>
                TreeMap<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> map <span class="sy0">=</span> <span class="kw1">new</span> TreeMap<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                b.<span class="me1">drainToMap</span><span class="br0">(</span>map<span class="br0">)</span><span class="sy0">;</span>
                addBlock<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw3">System</span>.<span class="me1">err</span>.<span class="me1">printf</span><span class="br0">(</span><span class="st0">"split N LEVEL  %d %d %d <span class="es0">\n</span>"</span>, split, N, level<span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">if</span> <span class="br0">(</span><span class="sy0">++</span>split <span class="sy0">&gt;=</span> <span class="br0">(</span>N <span class="sy0">&lt;&lt;</span> level<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
                        <span class="sy0">++</span>level<span class="sy0">;</span>
 
                        split <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
                <span class="br0">}</span>
 
                <span class="kw1">for</span> <span class="br0">(</span>K k <span class="sy0">:</span> map.<span class="me1">keySet</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
                        V v <span class="sy0">=</span> map.<span class="me1">get</span><span class="br0">(</span>k<span class="br0">)</span><span class="sy0">;</span>
                        <span class="kw4">int</span> h <span class="sy0">=</span> getDynamicHash<span class="br0">(</span>k.<span class="me1">hashCode</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                        <span class="kw3">System</span>.<span class="me1">err</span>.<span class="me1">println</span><span class="br0">(</span>h <span class="sy0">+</span> <span class="st0">" "</span><span class="br0">)</span><span class="sy0">;</span>
                        Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> b2 <span class="sy0">=</span> getBlock<span class="br0">(</span>h<span class="br0">)</span><span class="sy0">;</span>
                        b2.<span class="me1">put</span><span class="br0">(</span>k, v<span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
        <span class="br0">}</span>
 
        <span class="kw1">private</span> Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> addBlock<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> b <span class="sy0">=</span> <span class="kw1">new</span> Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span><span class="br0">(</span><span class="kw1">this</span><span class="br0">)</span><span class="sy0">;</span>
                blockList.<span class="me1">add</span><span class="br0">(</span>b<span class="br0">)</span><span class="sy0">;</span>
 
                <span class="kw1">return</span> b<span class="sy0">;</span>
        <span class="br0">}</span>
 
        @Override
        <span class="kw1">public</span> <span class="kw4">void</span> clear<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                blockList <span class="sy0">=</span> <span class="kw1">new</span> ArrayList<span class="sy0">&lt;</span>Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                split <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
                level <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
                totalWrites <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span><span class="co1">// savedBlocks = 0;</span>
 
        <span class="br0">}</span>
 
        @Override
        <span class="kw1">public</span> <span class="kw4">boolean</span> containsKey<span class="br0">(</span><span class="kw3">Object</span> key<span class="br0">)</span> <span class="br0">{</span>
                <span class="kw1">return</span> get<span class="br0">(</span>key<span class="br0">)</span> <span class="sy0">!=</span> <span class="kw2">null</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        @Override
        <span class="kw1">public</span> <span class="kw4">boolean</span> containsValue<span class="br0">(</span><span class="kw3">Object</span> value<span class="br0">)</span> <span class="br0">{</span>
                <span class="kw1">return</span> values<span class="br0">(</span><span class="br0">)</span>.<span class="me1">contains</span><span class="br0">(</span>value<span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        @Override
        <span class="kw1">public</span> Set<span class="sy0">&lt;</span>java.<span class="me1">util</span>.<span class="kw3">Map</span>.<span class="me1">Entry</span><span class="sy0">&lt;</span>K, V<span class="sy0">&gt;&gt;</span> entrySet<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                TreeSet<span class="sy0">&lt;</span><span class="kw3">Map</span>.<span class="me1">Entry</span><span class="sy0">&lt;</span>K, V<span class="sy0">&gt;&gt;</span> set <span class="sy0">=</span> <span class="kw1">new</span> TreeSet<span class="sy0">&lt;</span><span class="kw3">Map</span>.<span class="me1">Entry</span><span class="sy0">&lt;</span>K, V<span class="sy0">&gt;&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                Set<span class="sy0">&lt;</span>K<span class="sy0">&gt;</span> kk <span class="sy0">=</span> keySet<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">for</span> <span class="br0">(</span>K k <span class="sy0">:</span> kk<span class="br0">)</span> <span class="br0">{</span>
                        <span class="kw1">final</span> K k2 <span class="sy0">=</span> k<span class="sy0">;</span>
                        set.<span class="me1">add</span><span class="br0">(</span><span class="kw1">new</span> Entry<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
 
                                @Override
                                <span class="kw1">public</span> K getKey<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                                        <span class="kw1">return</span> k2<span class="sy0">;</span>
                                <span class="br0">}</span>
 
                                @Override
                                <span class="kw1">public</span> V getValue<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                                        <span class="kw1">return</span> get<span class="br0">(</span>k2<span class="br0">)</span><span class="sy0">;</span>
                                <span class="br0">}</span>
 
                                @Override
                                <span class="kw1">public</span> V setValue<span class="br0">(</span>V value<span class="br0">)</span> <span class="br0">{</span>
                                        <span class="kw1">return</span> put<span class="br0">(</span>k2, value<span class="br0">)</span><span class="sy0">;</span>
                                <span class="br0">}</span>
                        <span class="br0">}</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
                <span class="kw1">return</span> set<span class="sy0">;</span>
        <span class="br0">}</span>
 
        @Override
        <span class="kw1">public</span> V get<span class="br0">(</span><span class="kw3">Object</span> key<span class="br0">)</span> <span class="br0">{</span>
                <span class="kw4">int</span> h <span class="sy0">=</span> getDynamicHash<span class="br0">(</span>key.<span class="me1">hashCode</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> b <span class="sy0">=</span> getBlock<span class="br0">(</span>h<span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">return</span> b.<span class="me1">replace</span><span class="br0">(</span><span class="br0">(</span>K<span class="br0">)</span> key, <span class="kw2">null</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        @Override
        <span class="kw1">public</span> <span class="kw4">boolean</span> isEmpty<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                <span class="kw1">return</span> size<span class="br0">(</span><span class="br0">)</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        @Override
        <span class="kw1">public</span> Set<span class="sy0">&lt;</span>K<span class="sy0">&gt;</span> keySet<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                TreeSet<span class="sy0">&lt;</span>K<span class="sy0">&gt;</span> kk <span class="sy0">=</span> <span class="kw1">new</span> TreeSet<span class="sy0">&lt;</span>K<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> blockList.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> <span class="br0">{</span>
                        Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> b <span class="sy0">=</span> getBlock<span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
                        kk.<span class="me1">addAll</span><span class="br0">(</span>b.<span class="me1">keyList</span><span class="br0">)</span><span class="sy0">;</span>
                        Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> ov <span class="sy0">=</span> b.<span class="me1">overflow</span><span class="sy0">;</span>
                        <span class="kw1">while</span> <span class="br0">(</span>ov <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">)</span> <span class="br0">{</span>
                                kk.<span class="me1">addAll</span><span class="br0">(</span>ov.<span class="me1">keyList</span><span class="br0">)</span><span class="sy0">;</span>
                                ov <span class="sy0">=</span> ov.<span class="me1">overflow</span><span class="sy0">;</span>
                        <span class="br0">}</span>
                <span class="br0">}</span>
                <span class="kw1">return</span> kk<span class="sy0">;</span>
        <span class="br0">}</span>
 
        @Override
        <span class="kw1">public</span> <span class="kw4">void</span> putAll<span class="br0">(</span>Map<span class="sy0">&lt;?</span> <span class="kw1">extends</span> K, <span class="sy0">?</span> <span class="kw1">extends</span> V<span class="sy0">&gt;</span> m<span class="br0">)</span> <span class="br0">{</span>
                <span class="kw1">for</span> <span class="br0">(</span>K k <span class="sy0">:</span> m.<span class="me1">keySet</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
                        put<span class="br0">(</span>k, m.<span class="me1">get</span><span class="br0">(</span>k<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
        <span class="br0">}</span>
 
        @Override
        <span class="kw1">public</span> V remove<span class="br0">(</span><span class="kw3">Object</span> key<span class="br0">)</span> <span class="br0">{</span>
                <span class="kw1">return</span> <span class="kw2">null</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        @Override
        <span class="kw1">public</span> <span class="kw4">int</span> size<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                <span class="kw4">long</span> sz <span class="sy0">=</span> longSize<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">return</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="br0">(</span>sz <span class="sy0">&gt;</span> <span class="kw3">Integer</span>.<span class="me1">MAX_VALUE</span> <span class="sy0">?</span> <span class="kw3">Integer</span>.<span class="me1">MAX_VALUE</span>
                                <span class="sy0">:</span> sz<span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="kw1">public</span> <span class="kw4">long</span> longSize<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                <span class="kw4">long</span> sz <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
                <span class="kw1">for</span> <span class="br0">(</span>Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> b <span class="sy0">:</span> blockList<span class="br0">)</span> <span class="br0">{</span>
                        Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> b1 <span class="sy0">=</span> b<span class="sy0">;</span>
                        <span class="kw1">while</span> <span class="br0">(</span>b1 <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">)</span> <span class="br0">{</span>
                                sz <span class="sy0">+=</span> b1.<span class="me1">size</span><span class="sy0">;</span>
                                b1 <span class="sy0">=</span> b.<span class="me1">overflow</span><span class="sy0">;</span>
                        <span class="br0">}</span>
                <span class="br0">}</span>
                <span class="kw1">return</span> sz<span class="sy0">;</span>
        <span class="br0">}</span>
 
        @Override
        <span class="kw1">public</span> Collection<span class="sy0">&lt;</span>V<span class="sy0">&gt;</span> values<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                ArrayList<span class="sy0">&lt;</span>V<span class="sy0">&gt;</span> list <span class="sy0">=</span> <span class="kw1">new</span> ArrayList<span class="sy0">&lt;</span>V<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                Set<span class="sy0">&lt;</span>K<span class="sy0">&gt;</span> kk <span class="sy0">=</span> keySet<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">for</span> <span class="br0">(</span>K k <span class="sy0">:</span> kk<span class="br0">)</span> <span class="br0">{</span>
                        list.<span class="me1">add</span><span class="br0">(</span>get<span class="br0">(</span>k<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
                <span class="kw1">return</span> list<span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="kw1">private</span> <span class="kw4">void</span> showStructure<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
                <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> blockList.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> <span class="br0">{</span>
 
                        Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> b <span class="sy0">=</span> getBlock<span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
                        Block<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> ov <span class="sy0">=</span> b.<span class="me1">overflow</span><span class="sy0">;</span>
                        <span class="kw4">int</span> k <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
                        <span class="kw1">while</span> <span class="br0">(</span>ov <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">)</span> <span class="br0">{</span>
                                ov <span class="sy0">=</span> ov.<span class="me1">overflow</span><span class="sy0">;</span>
                                <span class="sy0">++</span>k<span class="sy0">;</span>
                        <span class="br0">}</span>
 
                        <span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Block "</span> <span class="sy0">+</span> i <span class="sy0">+</span> <span class="st0">" size "</span> <span class="sy0">+</span> b.<span class="me1">keyList</span>.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span>
                                        <span class="sy0">+</span> <span class="st0">" overflow blocks = "</span> <span class="sy0">+</span> k<span class="br0">)</span><span class="sy0">;</span>
 
                <span class="br0">}</span>
        <span class="br0">}</span>
 
<span class="br0">}</span>
</pre></div>
</div>
<p>Each block is a file in this implementation, because blocks are variably sized here to account for generics and variable sized key and value pairs, and overflow blocks are conceptual, not actual as on disc storage, because the block's contents and that of its overflow bucket(s), are saved as a list of alternating keys and values in this implementation. Methods for saving and loading to Object streams was used in a standard java customized object persistence way by implementing the Externalizable interface in the Block data class.</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="java source-java">
<pre class="de1">
<span class="kw1">package</span> <span class="co2">linearhashmap</span><span class="sy0">;</span>
 
<span class="kw1">import</span> <span class="co2">java.io.ByteArrayInputStream</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.io.ByteArrayOutputStream</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.io.File</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.io.FileInputStream</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.io.FileNotFoundException</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.io.FileOutputStream</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.io.IOException</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.io.ObjectInputStream</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.io.ObjectOutputStream</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.io.Serializable</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.util.ArrayList</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.util.Random</span><span class="sy0">;</span>
<span class="co3">/**
 * This class manages the LHMap2 class block disk swapping, and saves and load an instance of the LHMap2 class.
 * It has been used to externally index a legacy file based database of 100,000  record master table, and 1,000,000 record
 * sized child tables, and accounts for heap space available in the java virtual machine, so that OutOfMemory errors
 * are avoided when the heap space is low by putting blocks back on files, and garbage collecting them.
 * The main performance bottleneck appeared when loading a million record table for an index , on initial creation
 * of the index. 
 * @author doctor
 *
 * @param &lt;K&gt;
 * @param &lt;V&gt;
 */</span>
<span class="kw1">public</span> <span class="kw1">class</span> LHMap2BlockFileManager<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> <span class="kw1">implements</span>
                LHMap2.<span class="me1">BlockListener</span><span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span>, <span class="kw3">Serializable</span> <span class="br0">{</span>
 
        <span class="co3">/**
         * 
         */</span>
        <span class="kw1">private</span> <span class="kw1">static</span> <span class="kw1">final</span> <span class="kw4">long</span> serialVersionUID <span class="sy0">=</span> 2615265603397988894L<span class="sy0">;</span>
        LHMap2BlockFileManagerData data <span class="sy0">=</span> <span class="kw1">new</span> LHMap2BlockFileManagerData<span class="br0">(</span>
                        <span class="kw1">new</span> <span class="kw4">byte</span><span class="br0">[</span><span class="nu0">10000</span><span class="br0">]</span>, <span class="kw1">new</span> <span class="kw3">Random</span><span class="br0">(</span><span class="br0">)</span>, <span class="nu0">0</span>, <span class="kw1">new</span> ArrayList<span class="sy0">&lt;</span>Integer<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span>, <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
 
        <span class="kw1">public</span> LHMap2BlockFileManager<span class="br0">(</span><span class="kw3">File</span> baseDir, <span class="kw3">String</span> name, <span class="kw4">int</span> maxBlocks,
                        <span class="kw4">double</span> unloadRatio<span class="br0">)</span> <span class="br0">{</span>
                data.<span class="me1">home</span> <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">File</span><span class="br0">(</span>baseDir, name<span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>data.<span class="me1">home</span>.<span class="me1">exists</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
                        data.<span class="me1">home</span>.<span class="me1">mkdir</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">this</span>.<span class="me1">data</span>.<span class="me1">maxBlocks</span> <span class="sy0">=</span> maxBlocks<span class="sy0">;</span>
                <span class="kw1">this</span>.<span class="me1">data</span>.<span class="me1">unloadRatio</span> <span class="sy0">=</span> unloadRatio<span class="sy0">;</span>
        <span class="br0">}</span>
 
        @Override
        <span class="kw1">public</span> <span class="kw4">void</span> blockRequested<span class="br0">(</span><span class="kw4">int</span> block, LHMap2<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> map<span class="br0">)</span> <span class="br0">{</span>
                LHMap2.<span class="me1">Block</span><span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> b <span class="sy0">=</span> map.<span class="me1">blockList</span>.<span class="me1">get</span><span class="br0">(</span>block<span class="br0">)</span><span class="sy0">;</span>
 
                <span class="kw1">if</span> <span class="br0">(</span>b <span class="sy0">==</span> <span class="kw2">null</span><span class="br0">)</span> <span class="br0">{</span>
                        <span class="kw4">int</span> tries <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
                        <span class="kw3">File</span> f <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">File</span><span class="br0">(</span>data.<span class="me1">home</span>, <span class="kw3">Integer</span>.<span class="me1">toString</span><span class="br0">(</span>block<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                        <span class="kw1">do</span> <span class="br0">{</span>
 
                                <span class="kw1">if</span> <span class="br0">(</span>f.<span class="me1">exists</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
                                        <span class="kw1">break</span><span class="sy0">;</span>
 
                                <span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>f.<span class="me1">exists</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
                                        <span class="kw1">if</span> <span class="br0">(</span><span class="sy0">--</span>tries <span class="sy0">&gt;=</span> <span class="nu0">0</span><span class="br0">)</span>
                                                fatal<span class="br0">(</span>block<span class="br0">)</span><span class="sy0">;</span>
                                        <span class="kw1">try</span> <span class="br0">{</span>
 
                                                <span class="kw3">Thread</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">100</span><span class="br0">)</span><span class="sy0">;</span>
                                        <span class="br0">}</span> <span class="kw1">catch</span> <span class="br0">(</span><span class="kw3">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
                                                e.<span class="me1">printStackTrace</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                                        <span class="br0">}</span>
 
                                <span class="br0">}</span>
 
                        <span class="br0">}</span> <span class="kw1">while</span> <span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span><span class="sy0">;</span>
                        <span class="kw1">try</span> <span class="br0">{</span>
                                <span class="kw3">ByteArrayInputStream</span> bis <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">ByteArrayInputStream</span><span class="br0">(</span>data.<span class="me1">buf</span><span class="br0">)</span><span class="sy0">;</span>
                                <span class="kw3">FileInputStream</span> fis <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">FileInputStream</span><span class="br0">(</span>f<span class="br0">)</span><span class="sy0">;</span>
                                <span class="kw4">int</span> sz <span class="sy0">=</span> fis.<span class="me1">read</span><span class="br0">(</span>data.<span class="me1">buf</span><span class="br0">)</span><span class="sy0">;</span>
                                fis.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                                addByteStats<span class="br0">(</span>sz<span class="br0">)</span><span class="sy0">;</span>
                                <span class="kw3">ObjectInputStream</span> ois <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">ObjectInputStream</span><span class="br0">(</span>bis<span class="br0">)</span><span class="sy0">;</span>
                                b <span class="sy0">=</span> <span class="kw1">new</span> LHMap2.<span class="me1">Block</span><span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 
                                b.<span class="me1">readExternal</span><span class="br0">(</span>ois<span class="br0">)</span><span class="sy0">;</span>
                                ois.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                                b.<span class="me1">loadFromShadow</span><span class="br0">(</span>map<span class="br0">)</span><span class="sy0">;</span>
 
                                map.<span class="me1">blockList</span>.<span class="me1">set</span><span class="br0">(</span>block, b<span class="br0">)</span><span class="sy0">;</span>
                                <span class="sy0">--</span>data.<span class="me1">retired</span><span class="sy0">;</span>
 
                        <span class="br0">}</span> <span class="kw1">catch</span> <span class="br0">(</span><span class="kw3">FileNotFoundException</span> e<span class="br0">)</span> <span class="br0">{</span>
                                e.<span class="me1">printStackTrace</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                                fatal<span class="br0">(</span>block<span class="br0">)</span><span class="sy0">;</span>
                        <span class="br0">}</span> <span class="kw1">catch</span> <span class="br0">(</span><span class="kw3">IOException</span> e<span class="br0">)</span> <span class="br0">{</span>
                                e.<span class="me1">printStackTrace</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                                fatal<span class="br0">(</span>block<span class="br0">)</span><span class="sy0">;</span>
                        <span class="br0">}</span> <span class="kw1">catch</span> <span class="br0">(</span><span class="kw3">ClassNotFoundException</span> e<span class="br0">)</span> <span class="br0">{</span>
                                e.<span class="me1">printStackTrace</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                                fatal<span class="br0">(</span>block<span class="br0">)</span><span class="sy0">;</span>
                        <span class="br0">}</span>
 
                <span class="br0">}</span>
                <span class="kw4">int</span> size <span class="sy0">=</span> map.<span class="me1">blockList</span>.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 
                <span class="kw1">try</span> <span class="br0">{</span>
                        <span class="kw4">long</span> freeMemory <span class="sy0">=</span> <span class="kw3">Runtime</span>.<span class="me1">getRuntime</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">freeMemory</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 
                        <span class="kw4">long</span> limitMemory <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">long</span><span class="br0">)</span> <span class="br0">(</span>data.<span class="me1">avgBlockSize</span> <span class="sy0">*</span> data.<span class="me1">unloadRatio</span> <span class="sy0">*</span> size<span class="br0">)</span><span class="sy0">;</span>
 
                        <span class="kw1">if</span> <span class="br0">(</span>block <span class="sy0">%</span> <span class="nu0">30</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
                                <span class="kw3">System</span>.<span class="me1">err</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"free memory ="</span> <span class="sy0">+</span> freeMemory <span class="sy0">+</span> <span class="st0">" limit "</span>
                                                <span class="sy0">+</span> limitMemory<span class="br0">)</span><span class="sy0">;</span>
 
 
                        <span class="kw1">if</span> <span class="br0">(</span>map.<span class="me1">split</span> <span class="sy0">%</span> <span class="nu0">20</span> <span class="sy0">==</span> <span class="nu0">19</span><span class="br0">)</span> <span class="br0">{</span>
                                <span class="co1">// this is just to add statistics before really needing to retire</span>
                                retireRandomBlock<span class="br0">(</span>map, block<span class="br0">)</span><span class="sy0">;</span>
                                <span class="sy0">++</span>data.<span class="me1">retired</span><span class="sy0">;</span>
 
 
                        <span class="br0">}</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>freeMemory <span class="sy0">&lt;</span> limitMemory<span class="br0">)</span> <span class="br0">{</span>
                                <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> size <span class="sy0">/</span> <span class="nu0">4</span><span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> <span class="br0">{</span>
                                        retireRandomBlock<span class="br0">(</span>map, block<span class="br0">)</span><span class="sy0">;</span>
                                        <span class="sy0">++</span>data.<span class="me1">retired</span><span class="sy0">;</span>
                                <span class="br0">}</span>
                                <span class="kw3">System</span>.<span class="me1">runFinalization</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                                <span class="kw3">System</span>.<span class="me1">gc</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                        <span class="br0">}</span>
 
                <span class="br0">}</span> <span class="kw1">catch</span> <span class="br0">(</span><span class="kw3">FileNotFoundException</span> e<span class="br0">)</span> <span class="br0">{</span>
                        e.<span class="me1">printStackTrace</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span> <span class="kw1">catch</span> <span class="br0">(</span><span class="kw3">IOException</span> e<span class="br0">)</span> <span class="br0">{</span>
                        e.<span class="me1">printStackTrace</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
 
        <span class="br0">}</span>
 
        <span class="kw1">private</span> <span class="kw4">void</span> addByteStats<span class="br0">(</span><span class="kw4">int</span> sz<span class="br0">)</span> <span class="br0">{</span>
                <span class="sy0">++</span>data.<span class="me1">avgCount</span><span class="sy0">;</span>
                data.<span class="me1">avgBlockSize</span> <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="br0">(</span><span class="br0">(</span>data.<span class="me1">avgBlockSize</span>
                                <span class="sy0">*</span> <span class="br0">(</span>data.<span class="me1">avgCount</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span> <span class="sy0">+</span> sz<span class="br0">)</span> <span class="sy0">/</span> data.<span class="me1">avgCount</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="kw1">public</span> <span class="kw4">void</span> retireRandomBlock<span class="br0">(</span>LHMap2<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> map, <span class="kw4">int</span> notThisOne<span class="br0">)</span>
                        <span class="kw1">throws</span> <span class="kw3">FileNotFoundException</span>, <span class="kw3">IOException</span> <span class="br0">{</span>
                <span class="kw4">int</span> pick <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
                <span class="kw4">int</span> size <span class="sy0">=</span> map.<span class="me1">blockList</span>.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                LHMap2.<span class="me1">Block</span><span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> b <span class="sy0">=</span> <span class="kw2">null</span><span class="sy0">;</span>
 
                <span class="kw1">for</span> <span class="br0">(</span>pick <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> pick <span class="sy0">&lt;</span> size
                                <span class="sy0">&amp;&amp;</span> <span class="br0">(</span>pick <span class="sy0">==</span> notThisOne <span class="sy0">||</span> <span class="br0">(</span>b <span class="sy0">=</span> map.<span class="me1">blockList</span>.<span class="me1">get</span><span class="br0">(</span>pick<span class="br0">)</span><span class="br0">)</span> <span class="sy0">==</span> <span class="kw2">null</span><span class="br0">)</span><span class="sy0">;</span> <span class="sy0">++</span>pick<span class="br0">)</span>
                        <span class="sy0">;</span>
                <span class="kw1">if</span> <span class="br0">(</span>pick <span class="sy0">&lt;</span> size<span class="br0">)</span>
                        retireOneBlock<span class="br0">(</span>map, pick, b<span class="br0">)</span><span class="sy0">;</span>
 
        <span class="br0">}</span>
 
        <span class="kw1">private</span> <span class="kw4">void</span> retireOneBlock<span class="br0">(</span>LHMap2<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> map, <span class="kw4">int</span> pick, LHMap2.<span class="me1">Block</span><span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> b<span class="br0">)</span>
                        <span class="kw1">throws</span> <span class="kw3">IOException</span>, <span class="kw3">FileNotFoundException</span> <span class="br0">{</span>
                <span class="kw1">if</span> <span class="br0">(</span>b <span class="sy0">==</span> <span class="kw2">null</span><span class="br0">)</span>
                        <span class="kw1">return</span><span class="sy0">;</span>
 
                <span class="kw1">if</span> <span class="br0">(</span>b.<span class="me1">isChanged</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
 
                        <span class="co1">// System.err.println("Retiring " + pick);</span>
                        <span class="kw3">File</span> f <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">File</span><span class="br0">(</span>data.<span class="me1">home</span>, <span class="kw3">Integer</span>.<span class="me1">toString</span><span class="br0">(</span>pick<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                        <span class="kw3">ByteArrayOutputStream</span> bos <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">ByteArrayOutputStream</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 
                        <span class="kw3">ObjectOutputStream</span> oos <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">ObjectOutputStream</span><span class="br0">(</span>bos<span class="br0">)</span><span class="sy0">;</span>
                        b.<span class="me1">writeExternal</span><span class="br0">(</span>oos<span class="br0">)</span><span class="sy0">;</span>
                        oos.<span class="me1">flush</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                        oos.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                        <span class="kw3">FileOutputStream</span> fos <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">FileOutputStream</span><span class="br0">(</span>f<span class="br0">)</span><span class="sy0">;</span>
                        <span class="kw4">byte</span><span class="br0">[</span><span class="br0">]</span> bb <span class="sy0">=</span> bos.<span class="me1">toByteArray</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 
                        fos.<span class="me1">write</span><span class="br0">(</span>bb<span class="br0">)</span><span class="sy0">;</span>
                        fos.<span class="me1">flush</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                        fos.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                        <span class="kw1">if</span> <span class="br0">(</span>bb.<span class="me1">length</span> <span class="sy0">&gt;</span> data.<span class="me1">buf</span>.<span class="me1">length</span><span class="br0">)</span> <span class="br0">{</span>
                                data.<span class="me1">buf</span> <span class="sy0">=</span> bb<span class="sy0">;</span>
                        <span class="br0">}</span>
                <span class="br0">}</span>
                map.<span class="me1">blockList</span>.<span class="me1">set</span><span class="br0">(</span>pick, <span class="kw2">null</span><span class="br0">)</span><span class="sy0">;</span>
                b <span class="sy0">=</span> <span class="kw2">null</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="kw1">private</span> <span class="kw4">void</span> fatal<span class="br0">(</span><span class="kw4">int</span> block<span class="br0">)</span> <span class="br0">{</span>
                <span class="kw3">Exception</span> e <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">Exception</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">try</span> <span class="br0">{</span>
                        <span class="kw1">throw</span> e<span class="sy0">;</span>
                <span class="br0">}</span> <span class="kw1">catch</span> <span class="br0">(</span><span class="kw3">Exception</span> e2<span class="br0">)</span> <span class="br0">{</span>
                        e2.<span class="me1">printStackTrace</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
                <span class="kw3">System</span>.<span class="me1">err</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"block "</span> <span class="sy0">+</span> block
                                <span class="sy0">+</span> <span class="st0">" requested and it is not in blocklist and not a file"</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">:</span> data.<span class="me1">retirees</span><span class="br0">)</span> <span class="br0">{</span>
                        <span class="kw3">System</span>.<span class="me1">err</span>.<span class="me1">print</span><span class="br0">(</span>i <span class="sy0">+</span> <span class="st0">" "</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
                <span class="kw3">System</span>.<span class="me1">err</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">" were retired"</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw3">System</span>.<span class="me1">exit</span><span class="br0">(</span><span class="sy0">-</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">boolean</span> metaExists<span class="br0">(</span><span class="kw3">File</span> indexDir, <span class="kw3">String</span> name<span class="br0">)</span> <span class="br0">{</span>
                <span class="kw3">File</span> home <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">File</span><span class="br0">(</span>indexDir, name<span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">return</span> <span class="kw1">new</span> <span class="kw3">File</span><span class="br0">(</span>home, <span class="st0">"LinearMap2"</span><span class="br0">)</span>.<span class="me1">exists</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="kw1">public</span> <span class="kw1">static</span> <span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> LHMap2<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> load<span class="br0">(</span><span class="kw3">File</span> baseDir, <span class="kw3">String</span> name<span class="br0">)</span>
                        <span class="kw1">throws</span> <span class="kw3">FileNotFoundException</span>, <span class="kw3">IOException</span>, <span class="kw3">ClassNotFoundException</span> <span class="br0">{</span>
                <span class="kw3">File</span> home <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">File</span><span class="br0">(</span>baseDir, name<span class="br0">)</span><span class="sy0">;</span>
 
                <span class="kw3">File</span> f2 <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">File</span><span class="br0">(</span>home, <span class="st0">"LinearMap2"</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw3">ObjectInputStream</span> ois <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">ObjectInputStream</span><span class="br0">(</span><span class="kw1">new</span> <span class="kw3">FileInputStream</span><span class="br0">(</span>f2<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                LHMap2<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> map <span class="sy0">=</span> <span class="br0">(</span>LHMap2<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span><span class="br0">)</span> ois.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                ois.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                loadBlocks<span class="br0">(</span>map<span class="br0">)</span><span class="sy0">;</span>
 
                <span class="kw1">return</span> map<span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="kw1">private</span> <span class="kw1">static</span> <span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> <span class="kw4">void</span> loadBlocks<span class="br0">(</span>LHMap2<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> map<span class="br0">)</span> <span class="br0">{</span>
                LHMap2BlockFileManager<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> mgr <span class="sy0">=</span> getBlockManagerListener<span class="br0">(</span>map<span class="br0">)</span><span class="sy0">;</span>
                <span class="kw4">int</span> size <span class="sy0">=</span> map.<span class="me1">blockList</span>.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> size<span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> <span class="br0">{</span>
                        mgr.<span class="me1">blockRequested</span><span class="br0">(</span>i, map<span class="br0">)</span><span class="sy0">;</span>
                <span class="br0">}</span>
        <span class="br0">}</span>
 
        <span class="kw1">public</span> <span class="kw1">static</span> <span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> LHMap2BlockFileManager<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> getBlockManagerListener<span class="br0">(</span>
                        LHMap2<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> map<span class="br0">)</span> <span class="br0">{</span>
                LHMap2BlockFileManager<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> mgr <span class="sy0">=</span> <span class="br0">(</span>LHMap2BlockFileManager<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span><span class="br0">)</span> map.<span class="me1">listeners</span>
                                .<span class="me1">get</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">return</span> mgr<span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">void</span> save<span class="br0">(</span><span class="kw3">File</span> indexDir, <span class="kw3">String</span> name,
                        LHMap2<span class="sy0">&lt;?</span>, <span class="sy0">?&gt;</span> offsetMap<span class="br0">)</span> <span class="kw1">throws</span> <span class="kw3">FileNotFoundException</span>, <span class="kw3">IOException</span> <span class="br0">{</span>
                retireAllBlocks<span class="br0">(</span>offsetMap<span class="br0">)</span><span class="sy0">;</span>
 
                <span class="kw3">File</span> home <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">File</span><span class="br0">(</span>indexDir, name<span class="br0">)</span><span class="sy0">;</span>
                <span class="kw3">File</span> f2 <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">File</span><span class="br0">(</span>home, <span class="st0">"LinearMap2"</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw3">ObjectOutputStream</span> oos <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">ObjectOutputStream</span><span class="br0">(</span>
                                <span class="kw1">new</span> <span class="kw3">FileOutputStream</span><span class="br0">(</span>f2<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                oos.<span class="me1">writeObject</span><span class="br0">(</span>offsetMap<span class="br0">)</span><span class="sy0">;</span>
                oos.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
 
        <span class="kw1">private</span> <span class="kw1">static</span> <span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> <span class="kw4">void</span> retireAllBlocks<span class="br0">(</span>LHMap2<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> offsetMap<span class="br0">)</span>
                        <span class="kw1">throws</span> <span class="kw3">FileNotFoundException</span>, <span class="kw3">IOException</span> <span class="br0">{</span>
                LHMap2BlockFileManager<span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> mgr <span class="sy0">=</span> getBlockManagerListener<span class="br0">(</span>offsetMap<span class="br0">)</span><span class="sy0">;</span>
                <span class="kw4">int</span> sz <span class="sy0">=</span> offsetMap.<span class="me1">blockList</span>.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> sz<span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> <span class="br0">{</span>
                        LHMap2.<span class="me1">Block</span><span class="sy0">&lt;</span>K, V<span class="sy0">&gt;</span> b <span class="sy0">=</span> offsetMap.<span class="me1">blockList</span>.<span class="me1">get</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
                        <span class="co1">// offsetMap.blockList.set(i, null); // mark for reloading as block</span>
                        <span class="co1">// destroyed after writing</span>
                        <span class="kw1">if</span> <span class="br0">(</span>b <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">)</span> <span class="br0">{</span>
                                mgr.<span class="me1">retireOneBlock</span><span class="br0">(</span>offsetMap, i, b<span class="br0">)</span><span class="sy0">;</span>
                        <span class="br0">}</span>
 
                <span class="br0">}</span>
        <span class="br0">}</span>
<span class="br0">}</span>
</pre></div>
</div>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="java source-java">
<pre class="de1">
<span class="kw1">package</span> <span class="co2">linearhashmap</span><span class="sy0">;</span>
 
<span class="kw1">import</span> <span class="co2">java.io.File</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.io.Serializable</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.util.List</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.util.Random</span><span class="sy0">;</span>
 
<span class="kw1">public</span> <span class="kw1">class</span> LHMap2BlockFileManagerData <span class="kw1">implements</span>  <span class="kw3">Serializable</span><span class="br0">{</span>
        <span class="co3">/**
         * 
         */</span>
        <span class="kw1">private</span> <span class="kw1">static</span> <span class="kw1">final</span> <span class="kw4">long</span> serialVersionUID <span class="sy0">=</span> 1L<span class="sy0">;</span>
        <span class="kw1">public</span> <span class="kw4">byte</span><span class="br0">[</span><span class="br0">]</span> buf<span class="sy0">;</span>
        <span class="kw1">public</span> <span class="kw3">Random</span> r<span class="sy0">;</span>
        <span class="kw1">public</span> <span class="kw3">File</span> baseDir<span class="sy0">;</span>
        <span class="kw1">public</span> <span class="kw3">File</span> home<span class="sy0">;</span>
        <span class="kw1">public</span> <span class="kw4">int</span> maxBlocks<span class="sy0">;</span>
        <span class="kw1">public</span> <span class="kw4">int</span> retired<span class="sy0">;</span>
        <span class="kw1">public</span> <span class="kw4">double</span> unloadRatio<span class="sy0">;</span>
        <span class="kw1">public</span> List<span class="sy0">&lt;</span>Integer<span class="sy0">&gt;</span> retirees<span class="sy0">;</span>
        <span class="kw1">public</span> <span class="kw4">int</span> avgBlockSize<span class="sy0">;</span>
        <span class="kw1">public</span> <span class="kw4">long</span> avgCount<span class="sy0">;</span>
 
        <span class="kw1">public</span> LHMap2BlockFileManagerData<span class="br0">(</span><span class="kw4">byte</span><span class="br0">[</span><span class="br0">]</span> buf, <span class="kw3">Random</span> r, <span class="kw4">int</span> retired,
                        List<span class="sy0">&lt;</span>Integer<span class="sy0">&gt;</span> retirees, <span class="kw4">long</span> avgCount<span class="br0">)</span> <span class="br0">{</span>
                <span class="kw1">this</span>.<span class="me1">buf</span> <span class="sy0">=</span> buf<span class="sy0">;</span>
                <span class="kw1">this</span>.<span class="me1">r</span> <span class="sy0">=</span> r<span class="sy0">;</span>
                <span class="kw1">this</span>.<span class="me1">retired</span> <span class="sy0">=</span> retired<span class="sy0">;</span>
                <span class="kw1">this</span>.<span class="me1">retirees</span> <span class="sy0">=</span> retirees<span class="sy0">;</span>
                <span class="kw1">this</span>.<span class="me1">avgCount</span> <span class="sy0">=</span> avgCount<span class="sy0">;</span>
        <span class="br0">}</span>
 
 
<span class="br0">}</span>
</pre></div>
</div>
<hr />
<div style="width:60%; margin:0.5em auto; text-align:center; border:1px solid #003365; background:#E8FFE8; font-size:95%; white-space:nowrap;">
<p><b><a href="/wiki/Data_Structures" title="Data Structures">Data Structures</a></b><br />
<a href="/wiki/Data_Structures/Introduction" title="Data Structures/Introduction">Introduction</a> - <a href="/wiki/Data_Structures/Asymptotic_Notation" title="Data Structures/Asymptotic Notation">Asymptotic Notation</a> - <a href="/wiki/Data_Structures/Arrays" title="Data Structures/Arrays">Arrays</a> - <a href="/wiki/Data_Structures/List_Structures" title="Data Structures/List Structures">List Structures &amp; Iterators</a><br />
<a href="/wiki/Data_Structures/Stacks_and_Queues" title="Data Structures/Stacks and Queues">Stacks &amp; Queues</a> - <a href="/wiki/Data_Structures/Trees" title="Data Structures/Trees">Trees</a> - <a href="/wiki/Data_Structures/Min_and_Max_Heaps" title="Data Structures/Min and Max Heaps">Min &amp; Max Heaps</a> - <a href="/wiki/Data_Structures/Graphs" title="Data Structures/Graphs">Graphs</a><br />
<strong class="selflink">Hash Tables</strong> - <a href="/wiki/Data_Structures/Sets" title="Data Structures/Sets">Sets</a> - <a href="/wiki/Data_Structures/Tradeoffs" title="Data Structures/Tradeoffs">Tradeoffs</a></p>
</div>


<!-- 
NewPP limit report
Parsed by mw1051
CPU time usage: 0.684 seconds
Real time usage: 0.754 seconds
Preprocessor visited node count: 249/1000000
Preprocessor generated node count: 1681/1500000
Postâ€expand include size: 2087/2048000 bytes
Template argument size: 599/2048000 bytes
Highest expansion depth: 7/40
Expensive parser function count: 0/500
-->

<!-- Saved in parser cache with key enwikibooks:pcache:idhash:20098-0!*!0!!en!4!* and timestamp 20131128140436
 -->
<noscript><img src="//en.wikibooks.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" /></noscript></div>								<div class="printfooter">
				Retrieved from "<a href="http://en.wikibooks.org/w/index.php?title=Data_Structures/Hash_Tables&amp;oldid=2499014">http://en.wikibooks.org/w/index.php?title=Data_Structures/Hash_Tables&amp;oldid=2499014</a>"				</div>
												<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="/wiki/Category:Data_Structures" title="Category:Data Structures">Data Structures</a></li></ul></div></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Personal tools</h3>
	<ul>
<li id="pt-createaccount"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Data+Structures%2FHash+Tables&amp;type=signup">Create account</a></li><li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Data+Structures%2FHash+Tables" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Namespaces</h3>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="/wiki/Data_Structures/Hash_Tables"  title="View the content page [c]" accesskey="c">Book</a></span></li>
					<li  id="ca-talk"><span><a href="/wiki/Talk:Data_Structures/Hash_Tables"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Views</h3>
	<ul>
					<li id="ca-view" class="selected"><span><a href="/wiki/Data_Structures/Hash_Tables" >Read</a></span></li>
					<li id="ca-edit"><span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=edit"  title="You can edit this page. Please use the preview button before saving [e]" accesskey="e">Edit</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Actions</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Search</label></h3>
	<form action="/w/index.php" id="searchform">
				<div id="simpleSearch">
						<input name="search" placeholder="Search" title="Search Wikibooks [f]" accesskey="f" id="searchInput" />						<button type="submit" name="button" title="Search the pages for this text" id="searchButton"><img src="//bits.wikimedia.org/static-1.23wmf7/skins/vector/images/search-ltr.png?303-4" alt="Search" width="12" height="13" /></button>								<input type='hidden' name="title" value="Special:Search"/>
		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<div id="p-logo" role="banner"><a style="background-image: url(//upload.wikimedia.org/wikibooks/en/b/bc/Wiki.png);" href="/wiki/Main_Page"  title="Visit the main page"></a></div>
				<div class="portal" role="navigation" id='p-Navigation' aria-labelledby='p-Navigation-label'>
	<h3 id='p-Navigation-label'>Navigation</h3>
	<div class="body">
		<ul>
			<li id="n-mainpage"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main Page</a></li>
			<li id="n-help"><a href="/wiki/Help:Contents" title="Find help on how to use and edit Wikibooks">Help</a></li>
			<li id="n-Browse"><a href="/wiki/Wikibooks:Card_Catalog_Office" title="Check out what Wikibooks has to offer">Browse</a></li>
			<li id="n-Cookbook"><a href="/wiki/Cookbook:Table_of_Contents" title="Learn recipes from around the world">Cookbook</a></li>
			<li id="n-Wikijunior"><a href="/wiki/Wikijunior" title="Books for children">Wikijunior</a></li>
			<li id="n-Featured-books"><a href="/wiki/Wikibooks:Featured_books" title="The best of Wikibooks">Featured books</a></li>
			<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-sitesupport"><a href="//donate.wikimedia.org/wiki/Special:FundraiserRedirector?utm_source=donate&amp;utm_medium=sidebar&amp;utm_campaign=C13_en.wikibooks.org&amp;uselang=en" title="Support Wikibooks">Donations</a></li>
			<li id="n-randomrootpage"><a href="/wiki/Special:Randomrootpage">Random book</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-Community' aria-labelledby='p-Community-label'>
	<h3 id='p-Community-label'>Community</h3>
	<div class="body">
		<ul>
			<li id="n-Reading-room"><a href="/wiki/Wikibooks:Reading_room" title="Discuss Wikibooks-related questions and concerns with others">Reading room</a></li>
			<li id="n-portal"><a href="/wiki/Wikibooks:Community_Portal" title="Find your way around the Wikibooks community">Community portal</a></li>
			<li id="n-currentevents"><a href="/wiki/Wikibooks:Reading_room/Bulletin_Board" title="Important community news">Bulletin Board</a></li>
			<li id="n-maintenance"><a href="/wiki/Wikibooks:Maintenance" title="Frequent tasks that you can help with">Help out!</a></li>
			<li id="n-Policies-and-guidelines"><a href="/wiki/Wikibooks:Policies_and_guidelines" title="Pages detailing important rules and procedures">Policies and guidelines</a></li>
			<li id="n-contact"><a href="/wiki/Wikibooks:Contact_us" title="Alternative methods of communication">Contact us</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
	<h3 id='p-tb-label'>Tools</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Data_Structures/Hash_Tables" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Data_Structures/Hash_Tables" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-upload"><a href="//commons.wikimedia.org/wiki/Special:UploadWizard" title="Upload files [u]" accesskey="u">Upload file</a></li>
			<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-permalink"><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;oldid=2499014" title="Permanent link to this revision of the page">Permanent link</a></li>
			<li id="t-info"><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;action=info">Page information</a></li>
<li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=Data_Structures%2FHash_Tables&amp;id=2499014" title="Information on how to cite this page">Cite this page</a></li>		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-lang' aria-labelledby='p-lang-label'>
	<h3 id='p-lang-label'>In other languages</h3>
	<div class="body">
		<ul>
			<li class="uls-p-lang-dummy"><a href="#"></a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-Sister_projects' aria-labelledby='p-Sister_projects-label'>
	<h3 id='p-Sister_projects-label'>Sister projects</h3>
	<div class="body">
		<ul>
			<li id="n-Wikipedia"><a href="//en.wikipedia.org/wiki/Main_Page">Wikipedia</a></li>
			<li id="n-Wikiversity"><a href="//en.wikiversity.org/wiki/Wikiversity:Main_Page">Wikiversity</a></li>
			<li id="n-Wiktionary"><a href="//en.wiktionary.org/wiki/Wiktionary:Main_Page">Wiktionary</a></li>
			<li id="n-Wikiquote"><a href="//en.wikiquote.org/wiki/Main_Page">Wikiquote</a></li>
			<li id="n-Wikisource"><a href="//en.wikisource.org/wiki/Main_Page">Wikisource</a></li>
			<li id="n-Wikinews"><a href="//en.wikinews.org/wiki/Main_Page">Wikinews</a></li>
			<li id="n-Wikivoyage"><a href="//en.wikivoyage.org/wiki/Main_Page">Wikivoyage</a></li>
			<li id="n-Commons"><a href="//commons.wikimedia.org/wiki/Main_Page">Commons</a></li>
			<li id="n-Wikidata"><a href="//www.wikidata.org/wiki/Wikidata:Main_Page">Wikidata</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-coll-print_export' aria-labelledby='p-coll-print_export-label'>
	<h3 id='p-coll-print_export-label'>Print/export</h3>
	<div class="body">
		<ul>
			<li id="coll-create_a_book"><a href="/w/index.php?title=Special:Book&amp;bookcmd=book_creator&amp;referer=Data+Structures%2FHash+Tables">Create a collection</a></li>
			<li id="coll-download-as-rl"><a href="/w/index.php?title=Special:Book&amp;bookcmd=render_article&amp;arttitle=Data+Structures%2FHash+Tables&amp;oldid=2499014&amp;writer=rl">Download as PDF</a></li>
			<li id="t-print"><a href="/w/index.php?title=Data_Structures/Hash_Tables&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 8 March 2013, at 15:06.</li>
											<li id="footer-info-copyright">Text is available under the <a href="//creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution/Share-Alike License</a>; additional terms may apply.  By using this site, you agree to the <a href="//wikimediafoundation.org/wiki/Terms_of_Use">Terms of Use</a> and <a href="//wikimediafoundation.org/wiki/Privacy_policy">Privacy Policy.</a></li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="//wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="/wiki/Wikibooks:Welcome" title="Wikibooks:Welcome">About Wikibooks</a></li>
											<li id="footer-places-disclaimer"><a href="/wiki/Wikibooks:General_disclaimer" title="Wikibooks:General disclaimer">Disclaimers</a></li>
											<li id="footer-places-developers"><a class="external" href="https://www.mediawiki.org/wiki/Special:MyLanguage/How_to_contribute">Developers</a></li>
											<li id="footer-places-mobileview"><a href="//en.m.wikibooks.org/wiki/Data_Structures/Hash_Tables" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-copyrightico">
						<a href="//wikimediafoundation.org/"><img src="//bits.wikimedia.org/images/wikimedia-button.png" width="88" height="31" alt="Wikimedia Foundation"/></a>
					</li>
					<li id="footer-poweredbyico">
						<a href="//www.mediawiki.org/"><img src="//bits.wikimedia.org/static-1.23wmf7/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mobile.desktop","mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","ext.gadget.extlinks","mw.MwEmbedSupport.style","ext.wikimediaEvents.moduleStorage","ext.navigationTiming","schema.UniversalLanguageSelector","ext.uls.eventlogger","mw.PopUpMediaTransform","ext.flaggedRevs.advanced","skins.vector.collapsibleNav"],null,true);
}</script>
<script src="/w/index.php?title=MediaWiki:Gadget-commons-file.js&amp;action=raw&amp;ctype=text/javascript&amp;2172780"></script>
<script src="/w/index.php?title=MediaWiki:Gadget-toolboxcompat.js&amp;action=raw&amp;ctype=text/javascript&amp;2161931"></script>
<script src="//bits.wikimedia.org/en.wikibooks.org/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=vector&amp;*"></script>
<!-- Served by mw1087 in 0.166 secs. -->
	</body>
</html>
